import { r as __toESM, t as __commonJS } from "./chunk-DUEDWNxO.js";
import { t as require_prop_types } from "./prop-types-1UMy44yP.js";
import { t as require_react } from "./react-Cp03pb_8.js";
import { _ as clsx_default, a as useThemeWithoutDefault_default, c as styled$2, i as resolveProps, l as Global, n as useEnhancedEffect_default, o as internal_mutateStyles, p as ThemeContext, r as getThemeProps$1, s as internal_serializeStyles, t as identifier_default } from "./identifier-B78u7x71.js";
import { t as require_jsx_runtime } from "./jsx-runtime-2dA6yi1W.js";

//#region node_modules/@mui/utils/esm/composeClasses/composeClasses.js
/**
* Compose classes from multiple sources.
*
* @example
* ```tsx
* const slots = {
*  root: ['root', 'primary'],
*  label: ['label'],
* };
*
* const getUtilityClass = (slot) => `MuiButton-${slot}`;
*
* const classes = {
*   root: 'my-root-class',
* };
*
* const output = composeClasses(slots, getUtilityClass, classes);
* // {
* //   root: 'MuiButton-root MuiButton-primary my-root-class',
* //   label: 'MuiButton-label',
* // }
* ```
*
* @param slots a list of classes for each possible slot
* @param getUtilityClass a function to resolve the class based on the slot name
* @param classes the input classes from props
* @returns the resolved classes for all slots
*/
function composeClasses(slots, getUtilityClass, classes = void 0) {
	const output = {};
	for (const slotName in slots) {
		const slot = slots[slotName];
		let buffer = "";
		let start = true;
		for (let i = 0; i < slot.length; i += 1) {
			const value = slot[i];
			if (value) {
				buffer += (start === true ? "" : " ") + getUtilityClass(value);
				start = false;
				if (classes && classes[value]) buffer += " " + classes[value];
			}
		}
		output[slotName] = buffer;
	}
	return output;
}

//#endregion
//#region node_modules/@mui/utils/esm/capitalize/capitalize.js
function capitalize(string) {
	if (typeof string !== "string") throw new Error("MUI: `capitalize(string)` expects a string argument.");
	return string.charAt(0).toUpperCase() + string.slice(1);
}

//#endregion
//#region node_modules/react-is/cjs/react-is.development.js
/**
* @license React
* react-is.development.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_is_development = /* @__PURE__ */ __commonJS({ "node_modules/react-is/cjs/react-is.development.js": ((exports) => {
	(function() {
		function typeOf(object) {
			if ("object" === typeof object && null !== object) {
				var $$typeof = object.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE: switch (object = object.type, object) {
						case REACT_FRAGMENT_TYPE:
						case REACT_PROFILER_TYPE:
						case REACT_STRICT_MODE_TYPE:
						case REACT_SUSPENSE_TYPE:
						case REACT_SUSPENSE_LIST_TYPE:
						case REACT_VIEW_TRANSITION_TYPE: return object;
						default: switch (object = object && object.$$typeof, object) {
							case REACT_CONTEXT_TYPE:
							case REACT_FORWARD_REF_TYPE:
							case REACT_LAZY_TYPE:
							case REACT_MEMO_TYPE: return object;
							case REACT_CONSUMER_TYPE: return object;
							default: return $$typeof;
						}
					}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
		exports.ContextConsumer = REACT_CONSUMER_TYPE;
		exports.ContextProvider = REACT_CONTEXT_TYPE;
		exports.Element = REACT_ELEMENT_TYPE;
		exports.ForwardRef = REACT_FORWARD_REF_TYPE;
		exports.Fragment = REACT_FRAGMENT_TYPE;
		exports.Lazy = REACT_LAZY_TYPE;
		exports.Memo = REACT_MEMO_TYPE;
		exports.Portal = REACT_PORTAL_TYPE;
		exports.Profiler = REACT_PROFILER_TYPE;
		exports.StrictMode = REACT_STRICT_MODE_TYPE;
		exports.Suspense = REACT_SUSPENSE_TYPE;
		exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		exports.isContextConsumer = function(object) {
			return typeOf(object) === REACT_CONSUMER_TYPE;
		};
		exports.isContextProvider = function(object) {
			return typeOf(object) === REACT_CONTEXT_TYPE;
		};
		exports.isElement = function(object) {
			return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
		};
		exports.isForwardRef = function(object) {
			return typeOf(object) === REACT_FORWARD_REF_TYPE;
		};
		exports.isFragment = function(object) {
			return typeOf(object) === REACT_FRAGMENT_TYPE;
		};
		exports.isLazy = function(object) {
			return typeOf(object) === REACT_LAZY_TYPE;
		};
		exports.isMemo = function(object) {
			return typeOf(object) === REACT_MEMO_TYPE;
		};
		exports.isPortal = function(object) {
			return typeOf(object) === REACT_PORTAL_TYPE;
		};
		exports.isProfiler = function(object) {
			return typeOf(object) === REACT_PROFILER_TYPE;
		};
		exports.isStrictMode = function(object) {
			return typeOf(object) === REACT_STRICT_MODE_TYPE;
		};
		exports.isSuspense = function(object) {
			return typeOf(object) === REACT_SUSPENSE_TYPE;
		};
		exports.isSuspenseList = function(object) {
			return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
		};
		exports.isValidElementType = function(type) {
			return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
		};
		exports.typeOf = typeOf;
	})();
}) });

//#endregion
//#region node_modules/react-is/index.js
var require_react_is = /* @__PURE__ */ __commonJS({ "node_modules/react-is/index.js": ((exports, module) => {
	module.exports = require_react_is_development();
}) });

//#endregion
//#region node_modules/@mui/utils/esm/deepmerge/deepmerge.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_react_is$1 = /* @__PURE__ */ __toESM(require_react_is(), 1);
function isPlainObject(item) {
	if (typeof item !== "object" || item === null) return false;
	const prototype = Object.getPrototypeOf(item);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
	if (/* @__PURE__ */ import_react.isValidElement(source) || (0, import_react_is$1.isValidElementType)(source) || !isPlainObject(source)) return source;
	const output = {};
	Object.keys(source).forEach((key) => {
		output[key] = deepClone(source[key]);
	});
	return output;
}
/**
* Merge objects deeply.
* It will shallow copy React elements.
*
* If `options.clone` is set to `false` the source object will be merged directly into the target object.
*
* @example
* ```ts
* deepmerge({ a: { b: 1 }, d: 2 }, { a: { c: 2 }, d: 4 });
* // => { a: { b: 1, c: 2 }, d: 4 }
* ````
*
* @param target The target object.
* @param source The source object.
* @param options The merge options.
* @param options.clone Set to `false` to merge the source object directly into the target object.
* @returns The merged object.
*/
function deepmerge(target, source, options = { clone: true }) {
	const output = options.clone ? { ...target } : target;
	if (isPlainObject(target) && isPlainObject(source)) Object.keys(source).forEach((key) => {
		if (/* @__PURE__ */ import_react.isValidElement(source[key]) || (0, import_react_is$1.isValidElementType)(source[key])) output[key] = source[key];
		else if (isPlainObject(source[key]) && Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) output[key] = deepmerge(target[key], source[key], options);
		else if (options.clone) output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
		else output[key] = source[key];
	});
	return output;
}

//#endregion
//#region node_modules/@mui/system/esm/merge/merge.js
function merge(acc, item) {
	if (!item) return acc;
	return deepmerge(acc, item, { clone: false });
}
var merge_default = merge;

//#endregion
//#region node_modules/@mui/system/esm/responsivePropType/responsivePropType.js
var import_prop_types$8 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var responsivePropType = import_prop_types$8.default.oneOfType([
	import_prop_types$8.default.number,
	import_prop_types$8.default.string,
	import_prop_types$8.default.object,
	import_prop_types$8.default.array
]);
var responsivePropType_default = responsivePropType;

//#endregion
//#region node_modules/@mui/system/esm/cssContainerQueries/cssContainerQueries.js
/**
* For using in `sx` prop to sort the breakpoint from low to high.
* Note: this function does not work and will not support multiple units.
*       e.g. input: { '@container (min-width:300px)': '1rem', '@container (min-width:40rem)': '2rem' }
*            output: { '@container (min-width:40rem)': '2rem', '@container (min-width:300px)': '1rem' } // since 40 < 300 even though 40rem > 300px
*/
function sortContainerQueries(theme, css$1) {
	if (!theme.containerQueries) return css$1;
	const sorted = Object.keys(css$1).filter((key) => key.startsWith("@container")).sort((a, b) => {
		const regex = /min-width:\s*([0-9.]+)/;
		return +(a.match(regex)?.[1] || 0) - +(b.match(regex)?.[1] || 0);
	});
	if (!sorted.length) return css$1;
	return sorted.reduce((acc, key) => {
		const value = css$1[key];
		delete acc[key];
		acc[key] = value;
		return acc;
	}, { ...css$1 });
}
function isCqShorthand(breakpointKeys, value) {
	return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
}
function getContainerQuery(theme, shorthand) {
	const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
	if (!matches) throw new Error(`MUI: The provided shorthand ${`(${shorthand})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.\nFor example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.`);
	const [, containerQuery, containerName] = matches;
	const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
	return theme.containerQueries(containerName).up(value);
}
function cssContainerQueries(themeInput) {
	const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
	function attachCq(node$1, name) {
		node$1.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
		node$1.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
		node$1.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
		node$1.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
		node$1.not = (...args) => {
			const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
			if (result.includes("not all and")) return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
			return result;
		};
	}
	const node = {};
	const containerQueries = (name) => {
		attachCq(node, name);
		return node;
	};
	attachCq(containerQueries);
	return {
		...themeInput,
		containerQueries
	};
}

//#endregion
//#region node_modules/@mui/system/esm/breakpoints/breakpoints.js
const values = {
	xs: 0,
	sm: 600,
	md: 900,
	lg: 1200,
	xl: 1536
};
var defaultBreakpoints = {
	keys: [
		"xs",
		"sm",
		"md",
		"lg",
		"xl"
	],
	up: (key) => `@media (min-width:${values[key]}px)`
};
var defaultContainerQueries = { containerQueries: (containerName) => ({ up: (key) => {
	let result = typeof key === "number" ? key : values[key] || key;
	if (typeof result === "number") result = `${result}px`;
	return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
} }) };
function handleBreakpoints(props, propValue, styleFromPropValue) {
	const theme = props.theme || {};
	if (Array.isArray(propValue)) {
		const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
		return propValue.reduce((acc, item, index) => {
			acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
			return acc;
		}, {});
	}
	if (typeof propValue === "object") {
		const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
		return Object.keys(propValue).reduce((acc, breakpoint) => {
			if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
				const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
				if (containerKey) acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
			} else if (Object.keys(themeBreakpoints.values || values).includes(breakpoint)) {
				const mediaKey = themeBreakpoints.up(breakpoint);
				acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
			} else {
				const cssKey = breakpoint;
				acc[cssKey] = propValue[cssKey];
			}
			return acc;
		}, {});
	}
	return styleFromPropValue(propValue);
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
	return breakpointsInput.keys?.reduce((acc, key) => {
		const breakpointStyleKey = breakpointsInput.up(key);
		acc[breakpointStyleKey] = {};
		return acc;
	}, {}) || {};
}
function removeUnusedBreakpoints(breakpointKeys, style$2) {
	return breakpointKeys.reduce((acc, key) => {
		const breakpointOutput = acc[key];
		if (!breakpointOutput || Object.keys(breakpointOutput).length === 0) delete acc[key];
		return acc;
	}, style$2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles) {
	const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
	const mergedOutput = [emptyBreakpoints, ...styles].reduce((prev, next) => deepmerge(prev, next), {});
	return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
	if (typeof breakpointValues !== "object") return {};
	const base = {};
	const breakpointsKeys = Object.keys(themeBreakpoints);
	if (Array.isArray(breakpointValues)) breakpointsKeys.forEach((breakpoint, i) => {
		if (i < breakpointValues.length) base[breakpoint] = true;
	});
	else breakpointsKeys.forEach((breakpoint) => {
		if (breakpointValues[breakpoint] != null) base[breakpoint] = true;
	});
	return base;
}
function resolveBreakpointValues({ values: breakpointValues, breakpoints: themeBreakpoints, base: customBase }) {
	const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
	const keys = Object.keys(base);
	if (keys.length === 0) return breakpointValues;
	let previous;
	return keys.reduce((acc, breakpoint, i) => {
		if (Array.isArray(breakpointValues)) {
			acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
			previous = i;
		} else if (typeof breakpointValues === "object") {
			acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
			previous = breakpoint;
		} else acc[breakpoint] = breakpointValues;
		return acc;
	}, {});
}

//#endregion
//#region node_modules/@mui/system/esm/style/style.js
function getPath(obj, path, checkVars = true) {
	if (!path || typeof path !== "string") return null;
	if (obj && obj.vars && checkVars) {
		const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
		if (val != null) return val;
	}
	return path.split(".").reduce((acc, item) => {
		if (acc && acc[item] != null) return acc[item];
		return null;
	}, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
	let value;
	if (typeof themeMapping === "function") value = themeMapping(propValueFinal);
	else if (Array.isArray(themeMapping)) value = themeMapping[propValueFinal] || userValue;
	else value = getPath(themeMapping, propValueFinal) || userValue;
	if (transform) value = transform(value, userValue, themeMapping);
	return value;
}
function style$1(options) {
	const { prop, cssProperty = options.prop, themeKey, transform } = options;
	const fn = (props) => {
		if (props[prop] == null) return null;
		const propValue = props[prop];
		const theme = props.theme;
		const themeMapping = getPath(theme, themeKey) || {};
		const styleFromPropValue = (propValueFinal) => {
			let value = getStyleValue(themeMapping, transform, propValueFinal);
			if (propValueFinal === value && typeof propValueFinal === "string") value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
			if (cssProperty === false) return value;
			return { [cssProperty]: value };
		};
		return handleBreakpoints(props, propValue, styleFromPropValue);
	};
	fn.propTypes = { [prop]: responsivePropType_default };
	fn.filterProps = [prop];
	return fn;
}
var style_default = style$1;

//#endregion
//#region node_modules/@mui/system/esm/memoize/memoize.js
function memoize(fn) {
	const cache = {};
	return (arg$1) => {
		if (cache[arg$1] === void 0) cache[arg$1] = fn(arg$1);
		return cache[arg$1];
	};
}

//#endregion
//#region node_modules/@mui/system/esm/spacing/spacing.js
var properties = {
	m: "margin",
	p: "padding"
};
var directions = {
	t: "Top",
	r: "Right",
	b: "Bottom",
	l: "Left",
	x: ["Left", "Right"],
	y: ["Top", "Bottom"]
};
var aliases = {
	marginX: "mx",
	marginY: "my",
	paddingX: "px",
	paddingY: "py"
};
var getCssProperties = memoize((prop) => {
	if (prop.length > 2) if (aliases[prop]) prop = aliases[prop];
	else return [prop];
	const [a, b] = prop.split("");
	const property = properties[a];
	const direction = directions[b] || "";
	return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = [
	"m",
	"mt",
	"mr",
	"mb",
	"ml",
	"mx",
	"my",
	"margin",
	"marginTop",
	"marginRight",
	"marginBottom",
	"marginLeft",
	"marginX",
	"marginY",
	"marginInline",
	"marginInlineStart",
	"marginInlineEnd",
	"marginBlock",
	"marginBlockStart",
	"marginBlockEnd"
];
const paddingKeys = [
	"p",
	"pt",
	"pr",
	"pb",
	"pl",
	"px",
	"py",
	"padding",
	"paddingTop",
	"paddingRight",
	"paddingBottom",
	"paddingLeft",
	"paddingX",
	"paddingY",
	"paddingInline",
	"paddingInlineStart",
	"paddingInlineEnd",
	"paddingBlock",
	"paddingBlockStart",
	"paddingBlockEnd"
];
var spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
	const themeSpacing = getPath(theme, themeKey, true) ?? defaultValue;
	if (typeof themeSpacing === "number" || typeof themeSpacing === "string") return (val) => {
		if (typeof val === "string") return val;
		if (typeof val !== "number") console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${val}.`);
		if (typeof themeSpacing === "string") {
			if (themeSpacing.startsWith("var(") && val === 0) return 0;
			if (themeSpacing.startsWith("var(") && val === 1) return themeSpacing;
			return `calc(${val} * ${themeSpacing})`;
		}
		return themeSpacing * val;
	};
	if (Array.isArray(themeSpacing)) return (val) => {
		if (typeof val === "string") return val;
		const abs = Math.abs(val);
		if (!Number.isInteger(abs)) console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join("\n"));
		else if (abs > themeSpacing.length - 1) console.error([
			`MUI: The value provided (${abs}) overflows.`,
			`The supported values are: ${JSON.stringify(themeSpacing)}.`,
			`${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`
		].join("\n"));
		const transformed = themeSpacing[abs];
		if (val >= 0) return transformed;
		if (typeof transformed === "number") return -transformed;
		if (typeof transformed === "string" && transformed.startsWith("var(")) return `calc(-1 * ${transformed})`;
		return `-${transformed}`;
	};
	if (typeof themeSpacing === "function") return themeSpacing;
	console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join("\n"));
	return () => void 0;
}
function createUnarySpacing(theme) {
	return createUnaryUnit(theme, "spacing", 8, "spacing");
}
function getValue(transformer, propValue) {
	if (typeof propValue === "string" || propValue == null) return propValue;
	return transformer(propValue);
}
function getStyleFromPropValue(cssProperties, transformer) {
	return (propValue) => cssProperties.reduce((acc, cssProperty) => {
		acc[cssProperty] = getValue(transformer, propValue);
		return acc;
	}, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
	if (!keys.includes(prop)) return null;
	const styleFromPropValue = getStyleFromPropValue(getCssProperties(prop), transformer);
	const propValue = props[prop];
	return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
	const transformer = createUnarySpacing(props.theme);
	return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge_default, {});
}
function margin(props) {
	return style(props, marginKeys);
}
margin.propTypes = marginKeys.reduce((obj, key) => {
	obj[key] = responsivePropType_default;
	return obj;
}, {});
margin.filterProps = marginKeys;
function padding(props) {
	return style(props, paddingKeys);
}
padding.propTypes = paddingKeys.reduce((obj, key) => {
	obj[key] = responsivePropType_default;
	return obj;
}, {});
padding.filterProps = paddingKeys;
function spacing(props) {
	return style(props, spacingKeys);
}
spacing.propTypes = spacingKeys.reduce((obj, key) => {
	obj[key] = responsivePropType_default;
	return obj;
}, {});
spacing.filterProps = spacingKeys;

//#endregion
//#region node_modules/@mui/system/esm/compose/compose.js
function compose(...styles) {
	const handlers = styles.reduce((acc, style$2) => {
		style$2.filterProps.forEach((prop) => {
			acc[prop] = style$2;
		});
		return acc;
	}, {});
	const fn = (props) => {
		return Object.keys(props).reduce((acc, prop) => {
			if (handlers[prop]) return merge_default(acc, handlers[prop](props));
			return acc;
		}, {});
	};
	fn.propTypes = styles.reduce((acc, style$2) => Object.assign(acc, style$2.propTypes), {});
	fn.filterProps = styles.reduce((acc, style$2) => acc.concat(style$2.filterProps), []);
	return fn;
}
var compose_default = compose;

//#endregion
//#region node_modules/@mui/system/esm/borders/borders.js
function borderTransform(value) {
	if (typeof value !== "number") return value;
	return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
	return style_default({
		prop,
		themeKey: "borders",
		transform
	});
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
	if (props.borderRadius !== void 0 && props.borderRadius !== null) {
		const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius");
		const styleFromPropValue = (propValue) => ({ borderRadius: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
	}
	return null;
};
borderRadius.propTypes = { borderRadius: responsivePropType_default };
borderRadius.filterProps = ["borderRadius"];
var borders = compose_default(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);

//#endregion
//#region node_modules/@mui/system/esm/cssGrid/cssGrid.js
const gap = (props) => {
	if (props.gap !== void 0 && props.gap !== null) {
		const transformer = createUnaryUnit(props.theme, "spacing", 8, "gap");
		const styleFromPropValue = (propValue) => ({ gap: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.gap, styleFromPropValue);
	}
	return null;
};
gap.propTypes = { gap: responsivePropType_default };
gap.filterProps = ["gap"];
const columnGap = (props) => {
	if (props.columnGap !== void 0 && props.columnGap !== null) {
		const transformer = createUnaryUnit(props.theme, "spacing", 8, "columnGap");
		const styleFromPropValue = (propValue) => ({ columnGap: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.columnGap, styleFromPropValue);
	}
	return null;
};
columnGap.propTypes = { columnGap: responsivePropType_default };
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
	if (props.rowGap !== void 0 && props.rowGap !== null) {
		const transformer = createUnaryUnit(props.theme, "spacing", 8, "rowGap");
		const styleFromPropValue = (propValue) => ({ rowGap: getValue(transformer, propValue) });
		return handleBreakpoints(props, props.rowGap, styleFromPropValue);
	}
	return null;
};
rowGap.propTypes = { rowGap: responsivePropType_default };
rowGap.filterProps = ["rowGap"];
const gridColumn = style_default({ prop: "gridColumn" });
const gridRow = style_default({ prop: "gridRow" });
const gridAutoFlow = style_default({ prop: "gridAutoFlow" });
const gridAutoColumns = style_default({ prop: "gridAutoColumns" });
const gridAutoRows = style_default({ prop: "gridAutoRows" });
const gridTemplateColumns = style_default({ prop: "gridTemplateColumns" });
const gridTemplateRows = style_default({ prop: "gridTemplateRows" });
const gridTemplateAreas = style_default({ prop: "gridTemplateAreas" });
const gridArea = style_default({ prop: "gridArea" });
var grid = compose_default(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

//#endregion
//#region node_modules/@mui/system/esm/palette/palette.js
function paletteTransform(value, userValue) {
	if (userValue === "grey") return userValue;
	return value;
}
const color = style_default({
	prop: "color",
	themeKey: "palette",
	transform: paletteTransform
});
const bgcolor = style_default({
	prop: "bgcolor",
	cssProperty: "backgroundColor",
	themeKey: "palette",
	transform: paletteTransform
});
const backgroundColor = style_default({
	prop: "backgroundColor",
	themeKey: "palette",
	transform: paletteTransform
});
var palette = compose_default(color, bgcolor, backgroundColor);

//#endregion
//#region node_modules/@mui/system/esm/sizing/sizing.js
function sizingTransform(value) {
	return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style_default({
	prop: "width",
	transform: sizingTransform
});
const maxWidth = (props) => {
	if (props.maxWidth !== void 0 && props.maxWidth !== null) {
		const styleFromPropValue = (propValue) => {
			const breakpoint = props.theme?.breakpoints?.values?.[propValue] || values[propValue];
			if (!breakpoint) return { maxWidth: sizingTransform(propValue) };
			if (props.theme?.breakpoints?.unit !== "px") return { maxWidth: `${breakpoint}${props.theme.breakpoints.unit}` };
			return { maxWidth: breakpoint };
		};
		return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
	}
	return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style_default({
	prop: "minWidth",
	transform: sizingTransform
});
const height = style_default({
	prop: "height",
	transform: sizingTransform
});
const maxHeight = style_default({
	prop: "maxHeight",
	transform: sizingTransform
});
const minHeight = style_default({
	prop: "minHeight",
	transform: sizingTransform
});
const sizeWidth = style_default({
	prop: "size",
	cssProperty: "width",
	transform: sizingTransform
});
const sizeHeight = style_default({
	prop: "size",
	cssProperty: "height",
	transform: sizingTransform
});
const boxSizing = style_default({ prop: "boxSizing" });
var sizing = compose_default(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);

//#endregion
//#region node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js
var defaultSxConfig = {
	border: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderTop: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderRight: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderBottom: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderLeft: {
		themeKey: "borders",
		transform: borderTransform
	},
	borderColor: { themeKey: "palette" },
	borderTopColor: { themeKey: "palette" },
	borderRightColor: { themeKey: "palette" },
	borderBottomColor: { themeKey: "palette" },
	borderLeftColor: { themeKey: "palette" },
	outline: {
		themeKey: "borders",
		transform: borderTransform
	},
	outlineColor: { themeKey: "palette" },
	borderRadius: {
		themeKey: "shape.borderRadius",
		style: borderRadius
	},
	color: {
		themeKey: "palette",
		transform: paletteTransform
	},
	bgcolor: {
		themeKey: "palette",
		cssProperty: "backgroundColor",
		transform: paletteTransform
	},
	backgroundColor: {
		themeKey: "palette",
		transform: paletteTransform
	},
	p: { style: padding },
	pt: { style: padding },
	pr: { style: padding },
	pb: { style: padding },
	pl: { style: padding },
	px: { style: padding },
	py: { style: padding },
	padding: { style: padding },
	paddingTop: { style: padding },
	paddingRight: { style: padding },
	paddingBottom: { style: padding },
	paddingLeft: { style: padding },
	paddingX: { style: padding },
	paddingY: { style: padding },
	paddingInline: { style: padding },
	paddingInlineStart: { style: padding },
	paddingInlineEnd: { style: padding },
	paddingBlock: { style: padding },
	paddingBlockStart: { style: padding },
	paddingBlockEnd: { style: padding },
	m: { style: margin },
	mt: { style: margin },
	mr: { style: margin },
	mb: { style: margin },
	ml: { style: margin },
	mx: { style: margin },
	my: { style: margin },
	margin: { style: margin },
	marginTop: { style: margin },
	marginRight: { style: margin },
	marginBottom: { style: margin },
	marginLeft: { style: margin },
	marginX: { style: margin },
	marginY: { style: margin },
	marginInline: { style: margin },
	marginInlineStart: { style: margin },
	marginInlineEnd: { style: margin },
	marginBlock: { style: margin },
	marginBlockStart: { style: margin },
	marginBlockEnd: { style: margin },
	displayPrint: {
		cssProperty: false,
		transform: (value) => ({ "@media print": { display: value } })
	},
	display: {},
	overflow: {},
	textOverflow: {},
	visibility: {},
	whiteSpace: {},
	flexBasis: {},
	flexDirection: {},
	flexWrap: {},
	justifyContent: {},
	alignItems: {},
	alignContent: {},
	order: {},
	flex: {},
	flexGrow: {},
	flexShrink: {},
	alignSelf: {},
	justifyItems: {},
	justifySelf: {},
	gap: { style: gap },
	rowGap: { style: rowGap },
	columnGap: { style: columnGap },
	gridColumn: {},
	gridRow: {},
	gridAutoFlow: {},
	gridAutoColumns: {},
	gridAutoRows: {},
	gridTemplateColumns: {},
	gridTemplateRows: {},
	gridTemplateAreas: {},
	gridArea: {},
	position: {},
	zIndex: { themeKey: "zIndex" },
	top: {},
	right: {},
	bottom: {},
	left: {},
	boxShadow: { themeKey: "shadows" },
	width: { transform: sizingTransform },
	maxWidth: { style: maxWidth },
	minWidth: { transform: sizingTransform },
	height: { transform: sizingTransform },
	maxHeight: { transform: sizingTransform },
	minHeight: { transform: sizingTransform },
	boxSizing: {},
	font: { themeKey: "font" },
	fontFamily: { themeKey: "typography" },
	fontSize: { themeKey: "typography" },
	fontStyle: { themeKey: "typography" },
	fontWeight: { themeKey: "typography" },
	letterSpacing: {},
	textTransform: {},
	lineHeight: {},
	textAlign: {},
	typography: {
		cssProperty: false,
		themeKey: "typography"
	}
};
var defaultSxConfig_default = defaultSxConfig;

//#endregion
//#region node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js
function objectsHaveSameKeys(...objects) {
	const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
	const union = new Set(allKeys);
	return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg$1) {
	return typeof maybeFn === "function" ? maybeFn(arg$1) : maybeFn;
}
function unstable_createStyleFunctionSx() {
	function getThemeValue(prop, val, theme, config) {
		const props = {
			[prop]: val,
			theme
		};
		const options = config[prop];
		if (!options) return { [prop]: val };
		const { cssProperty = prop, themeKey, transform, style: style$2 } = options;
		if (val == null) return null;
		if (themeKey === "typography" && val === "inherit") return { [prop]: val };
		const themeMapping = getPath(theme, themeKey) || {};
		if (style$2) return style$2(props);
		const styleFromPropValue = (propValueFinal) => {
			let value = getStyleValue(themeMapping, transform, propValueFinal);
			if (propValueFinal === value && typeof propValueFinal === "string") value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
			if (cssProperty === false) return value;
			return { [cssProperty]: value };
		};
		return handleBreakpoints(props, val, styleFromPropValue);
	}
	function styleFunctionSx$1(props) {
		const { sx, theme = {}, nested } = props || {};
		if (!sx) return null;
		const config = theme.unstable_sxConfig ?? defaultSxConfig_default;
		function traverse(sxInput) {
			let sxObject = sxInput;
			if (typeof sxInput === "function") sxObject = sxInput(theme);
			else if (typeof sxInput !== "object") return sxInput;
			if (!sxObject) return null;
			const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
			const breakpointsKeys = Object.keys(emptyBreakpoints);
			let css$1 = emptyBreakpoints;
			Object.keys(sxObject).forEach((styleKey) => {
				const value = callIfFn(sxObject[styleKey], theme);
				if (value !== null && value !== void 0) if (typeof value === "object") if (config[styleKey]) css$1 = merge_default(css$1, getThemeValue(styleKey, value, theme, config));
				else {
					const breakpointsValues = handleBreakpoints({ theme }, value, (x) => ({ [styleKey]: x }));
					if (objectsHaveSameKeys(breakpointsValues, value)) css$1[styleKey] = styleFunctionSx$1({
						sx: value,
						theme,
						nested: true
					});
					else css$1 = merge_default(css$1, breakpointsValues);
				}
				else css$1 = merge_default(css$1, getThemeValue(styleKey, value, theme, config));
			});
			if (!nested && theme.modularCssLayers) return { "@layer sx": sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css$1)) };
			return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css$1));
		}
		return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
	}
	return styleFunctionSx$1;
}
var styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
var styleFunctionSx_default = styleFunctionSx;

//#endregion
//#region node_modules/@mui/styled-engine/esm/GlobalStyles/GlobalStyles.js
var import_prop_types$7 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
function isEmpty(obj) {
	return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles(props) {
	const { styles, defaultTheme: defaultTheme$2 = {} } = props;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Global, { styles: typeof styles === "function" ? (themeInput) => styles(isEmpty(themeInput) ? defaultTheme$2 : themeInput) : styles });
}
GlobalStyles.propTypes = {
	defaultTheme: import_prop_types$7.default.object,
	styles: import_prop_types$7.default.oneOfType([
		import_prop_types$7.default.array,
		import_prop_types$7.default.string,
		import_prop_types$7.default.object,
		import_prop_types$7.default.func
	])
};

//#endregion
//#region node_modules/@mui/system/esm/createBreakpoints/createBreakpoints.js
var sortBreakpointsValues = (values$1) => {
	const breakpointsAsArray = Object.keys(values$1).map((key) => ({
		key,
		val: values$1[key]
	})) || [];
	breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
	return breakpointsAsArray.reduce((acc, obj) => {
		return {
			...acc,
			[obj.key]: obj.val
		};
	}, {});
};
function createBreakpoints(breakpoints) {
	const { values: values$1 = {
		xs: 0,
		sm: 600,
		md: 900,
		lg: 1200,
		xl: 1536
	}, unit = "px", step = 5,...other } = breakpoints;
	const sortedValues = sortBreakpointsValues(values$1);
	const keys = Object.keys(sortedValues);
	function up(key) {
		return `@media (min-width:${typeof values$1[key] === "number" ? values$1[key] : key}${unit})`;
	}
	function down(key) {
		return `@media (max-width:${(typeof values$1[key] === "number" ? values$1[key] : key) - step / 100}${unit})`;
	}
	function between(start, end) {
		const endIndex = keys.indexOf(end);
		return `@media (min-width:${typeof values$1[start] === "number" ? values$1[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values$1[keys[endIndex]] === "number" ? values$1[keys[endIndex]] : end) - step / 100}${unit})`;
	}
	function only(key) {
		if (keys.indexOf(key) + 1 < keys.length) return between(key, keys[keys.indexOf(key) + 1]);
		return up(key);
	}
	function not(key) {
		const keyIndex = keys.indexOf(key);
		if (keyIndex === 0) return up(keys[1]);
		if (keyIndex === keys.length - 1) return down(keys[keyIndex]);
		return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
	}
	return {
		keys,
		values: sortedValues,
		up,
		down,
		between,
		only,
		not,
		unit,
		...other
	};
}

//#endregion
//#region node_modules/@mui/system/esm/createTheme/shape.js
var shape = { borderRadius: 4 };
var shape_default = shape;

//#endregion
//#region node_modules/@mui/system/esm/createTheme/createSpacing.js
function createSpacing(spacingInput = 8, transform = createUnarySpacing({ spacing: spacingInput })) {
	if (spacingInput.mui) return spacingInput;
	const spacing$1 = (...argsInput) => {
		if (!(argsInput.length <= 4)) console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
		return (argsInput.length === 0 ? [1] : argsInput).map((argument) => {
			const output = transform(argument);
			return typeof output === "number" ? `${output}px` : output;
		}).join(" ");
	};
	spacing$1.mui = true;
	return spacing$1;
}

//#endregion
//#region node_modules/@mui/system/esm/createTheme/applyStyles.js
/**
* A universal utility to style components with multiple color modes. Always use it from the theme object.
* It works with:
*  - [Basic theme](https://mui.com/material-ui/customization/dark-mode/)
*  - [CSS theme variables](https://mui.com/material-ui/customization/css-theme-variables/overview/)
*  - Zero-runtime engine
*
* Tips: Use an array over object spread and place `theme.applyStyles()` last.
*
* With the styled function:
* âœ… [{ background: '#e5e5e5' }, theme.applyStyles('dark', { background: '#1c1c1c' })]
* ðŸš« { background: '#e5e5e5', ...theme.applyStyles('dark', { background: '#1c1c1c' })}
*
* With the sx prop:
* âœ… [{ background: '#e5e5e5' }, theme => theme.applyStyles('dark', { background: '#1c1c1c' })]
* ðŸš« { background: '#e5e5e5', ...theme => theme.applyStyles('dark', { background: '#1c1c1c' })}
*
* @example
* 1. using with `styled`:
* ```jsx
*   const Component = styled('div')(({ theme }) => [
*     { background: '#e5e5e5' },
*     theme.applyStyles('dark', {
*       background: '#1c1c1c',
*       color: '#fff',
*     }),
*   ]);
* ```
*
* @example
* 2. using with `sx` prop:
* ```jsx
*   <Box sx={[
*     { background: '#e5e5e5' },
*     theme => theme.applyStyles('dark', {
*        background: '#1c1c1c',
*        color: '#fff',
*      }),
*     ]}
*   />
* ```
*
* @example
* 3. theming a component:
* ```jsx
*   extendTheme({
*     components: {
*       MuiButton: {
*         styleOverrides: {
*           root: ({ theme }) => [
*             { background: '#e5e5e5' },
*             theme.applyStyles('dark', {
*               background: '#1c1c1c',
*               color: '#fff',
*             }),
*           ],
*         },
*       }
*     }
*   })
*```
*/
function applyStyles(key, styles) {
	const theme = this;
	if (theme.vars) {
		if (!theme.colorSchemes?.[key] || typeof theme.getColorSchemeSelector !== "function") return {};
		let selector = theme.getColorSchemeSelector(key);
		if (selector === "&") return styles;
		if (selector.includes("data-") || selector.includes(".")) selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
		return { [selector]: styles };
	}
	if (theme.palette.mode === key) return styles;
	return {};
}

//#endregion
//#region node_modules/@mui/system/esm/createTheme/createTheme.js
function createTheme$1(options = {}, ...args) {
	const { breakpoints: breakpointsInput = {}, palette: paletteInput = {}, spacing: spacingInput, shape: shapeInput = {},...other } = options;
	const breakpoints = createBreakpoints(breakpointsInput);
	const spacing$1 = createSpacing(spacingInput);
	let muiTheme = deepmerge({
		breakpoints,
		direction: "ltr",
		components: {},
		palette: {
			mode: "light",
			...paletteInput
		},
		spacing: spacing$1,
		shape: {
			...shape_default,
			...shapeInput
		}
	}, other);
	muiTheme = cssContainerQueries(muiTheme);
	muiTheme.applyStyles = applyStyles;
	muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
	muiTheme.unstable_sxConfig = {
		...defaultSxConfig_default,
		...other?.unstable_sxConfig
	};
	muiTheme.unstable_sx = function sx(props) {
		return styleFunctionSx_default({
			sx: props,
			theme: this
		});
	};
	return muiTheme;
}
var createTheme_default = createTheme$1;

//#endregion
//#region node_modules/@mui/system/esm/useTheme/useTheme.js
const systemDefaultTheme$1 = createTheme_default();
function useTheme$1(defaultTheme$2 = systemDefaultTheme$1) {
	return useThemeWithoutDefault_default(defaultTheme$2);
}
var useTheme_default = useTheme$1;

//#endregion
//#region node_modules/@mui/system/esm/GlobalStyles/GlobalStyles.js
var import_prop_types$6 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
function wrapGlobalLayer(styles) {
	const serialized = internal_serializeStyles(styles);
	if (styles !== serialized && serialized.styles) {
		if (!serialized.styles.match(/^@layer\s+[^{]*$/)) serialized.styles = `@layer global{${serialized.styles}}`;
		return serialized;
	}
	return styles;
}
function GlobalStyles$1({ styles, themeId, defaultTheme: defaultTheme$2 = {} }) {
	const upperTheme = useTheme_default(defaultTheme$2);
	const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
	let globalStyles = typeof styles === "function" ? styles(resolvedTheme) : styles;
	if (resolvedTheme.modularCssLayers) if (Array.isArray(globalStyles)) globalStyles = globalStyles.map((styleArg) => {
		if (typeof styleArg === "function") return wrapGlobalLayer(styleArg(resolvedTheme));
		return wrapGlobalLayer(styleArg);
	});
	else globalStyles = wrapGlobalLayer(globalStyles);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GlobalStyles, { styles: globalStyles });
}
GlobalStyles$1.propTypes = {
	defaultTheme: import_prop_types$6.default.object,
	styles: import_prop_types$6.default.oneOfType([
		import_prop_types$6.default.array,
		import_prop_types$6.default.func,
		import_prop_types$6.default.number,
		import_prop_types$6.default.object,
		import_prop_types$6.default.string,
		import_prop_types$6.default.bool
	]),
	themeId: import_prop_types$6.default.string
};
var GlobalStyles_default = GlobalStyles$1;

//#endregion
//#region node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js
var defaultGenerator = (componentName) => componentName;
var createClassNameGenerator = () => {
	let generate = defaultGenerator;
	return {
		configure(generator) {
			generate = generator;
		},
		generate(componentName) {
			return generate(componentName);
		},
		reset() {
			generate = defaultGenerator;
		}
	};
};
var ClassNameGenerator = createClassNameGenerator();
var ClassNameGenerator_default = ClassNameGenerator;

//#endregion
//#region node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js
const globalStateClasses = {
	active: "active",
	checked: "checked",
	completed: "completed",
	disabled: "disabled",
	error: "error",
	expanded: "expanded",
	focused: "focused",
	focusVisible: "focusVisible",
	open: "open",
	readOnly: "readOnly",
	required: "required",
	selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
	const globalStateClass = globalStateClasses[slot];
	return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator_default.generate(componentName)}-${slot}`;
}

//#endregion
//#region node_modules/@mui/utils/esm/getDisplayName/getDisplayName.js
var import_react_is = /* @__PURE__ */ __toESM(require_react_is(), 1);
function getFunctionComponentName(Component, fallback = "") {
	return Component.displayName || Component.name || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
	const functionName = getFunctionComponentName(innerType);
	return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
/**
* cherry-pick from
* https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
* originally forked from recompose/getDisplayName
*/
function getDisplayName(Component) {
	if (Component == null) return;
	if (typeof Component === "string") return Component;
	if (typeof Component === "function") return getFunctionComponentName(Component, "Component");
	if (typeof Component === "object") switch (Component.$$typeof) {
		case import_react_is.ForwardRef: return getWrappedName(Component, Component.render, "ForwardRef");
		case import_react_is.Memo: return getWrappedName(Component, Component.type, "memo");
		default: return;
	}
}

//#endregion
//#region node_modules/@mui/system/esm/preprocessStyles.js
function preprocessStyles(input) {
	const { variants,...style$2 } = input;
	const result = {
		variants,
		style: internal_serializeStyles(style$2),
		isProcessed: true
	};
	if (result.style === style$2) return result;
	if (variants) variants.forEach((variant) => {
		if (typeof variant.style !== "function") variant.style = internal_serializeStyles(variant.style);
	});
	return result;
}

//#endregion
//#region node_modules/@mui/system/esm/createStyled/createStyled.js
const systemDefaultTheme = createTheme_default();
function shouldForwardProp(prop) {
	return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function shallowLayer(serialized, layerName) {
	if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
	return serialized;
}
function defaultOverridesResolver(slot) {
	if (!slot) return null;
	return (_props, styles) => styles[slot];
}
function attachTheme(props, themeId, defaultTheme$2) {
	props.theme = isObjectEmpty(props.theme) ? defaultTheme$2 : props.theme[themeId] || props.theme;
}
function processStyle(props, style$2, layerName) {
	const resolvedStyle = typeof style$2 === "function" ? style$2(props) : style$2;
	if (Array.isArray(resolvedStyle)) return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle, layerName));
	if (Array.isArray(resolvedStyle?.variants)) {
		let rootStyle;
		if (resolvedStyle.isProcessed) rootStyle = layerName ? shallowLayer(resolvedStyle.style, layerName) : resolvedStyle.style;
		else {
			const { variants,...otherStyles } = resolvedStyle;
			rootStyle = layerName ? shallowLayer(internal_serializeStyles(otherStyles), layerName) : otherStyles;
		}
		return processStyleVariants(props, resolvedStyle.variants, [rootStyle], layerName);
	}
	if (resolvedStyle?.isProcessed) return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle.style), layerName) : resolvedStyle.style;
	return layerName ? shallowLayer(internal_serializeStyles(resolvedStyle), layerName) : resolvedStyle;
}
function processStyleVariants(props, variants, results = [], layerName = void 0) {
	let mergedState;
	variantLoop: for (let i = 0; i < variants.length; i += 1) {
		const variant = variants[i];
		if (typeof variant.props === "function") {
			mergedState ??= {
				...props,
				...props.ownerState,
				ownerState: props.ownerState
			};
			if (!variant.props(mergedState)) continue;
		} else for (const key in variant.props) if (props[key] !== variant.props[key] && props.ownerState?.[key] !== variant.props[key]) continue variantLoop;
		if (typeof variant.style === "function") {
			mergedState ??= {
				...props,
				...props.ownerState,
				ownerState: props.ownerState
			};
			results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style(mergedState)), layerName) : variant.style(mergedState));
		} else results.push(layerName ? shallowLayer(internal_serializeStyles(variant.style), layerName) : variant.style);
	}
	return results;
}
function createStyled(input = {}) {
	const { themeId, defaultTheme: defaultTheme$2 = systemDefaultTheme, rootShouldForwardProp: rootShouldForwardProp$1 = shouldForwardProp, slotShouldForwardProp: slotShouldForwardProp$1 = shouldForwardProp } = input;
	function styleAttachTheme(props) {
		attachTheme(props, themeId, defaultTheme$2);
	}
	const styled$3 = (tag, inputOptions = {}) => {
		internal_mutateStyles(tag, (styles) => styles.filter((style$2) => style$2 !== styleFunctionSx_default));
		const { name: componentName, slot: componentSlot, skipVariantsResolver: inputSkipVariantsResolver, skipSx: inputSkipSx, overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot)),...options } = inputOptions;
		const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
		const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false;
		const skipSx = inputSkipSx || false;
		let shouldForwardPropOption = shouldForwardProp;
		if (componentSlot === "Root" || componentSlot === "root") shouldForwardPropOption = rootShouldForwardProp$1;
		else if (componentSlot) shouldForwardPropOption = slotShouldForwardProp$1;
		else if (isStringTag(tag)) shouldForwardPropOption = void 0;
		const defaultStyledResolver = styled$2(tag, {
			shouldForwardProp: shouldForwardPropOption,
			label: generateStyledLabel(componentName, componentSlot),
			...options
		});
		const transformStyle = (style$2) => {
			if (style$2.__emotion_real === style$2) return style$2;
			if (typeof style$2 === "function") return function styleFunctionProcessor(props) {
				return processStyle(props, style$2, props.theme.modularCssLayers ? layerName : void 0);
			};
			if (isPlainObject(style$2)) {
				const serialized = preprocessStyles(style$2);
				return function styleObjectProcessor(props) {
					if (!serialized.variants) return props.theme.modularCssLayers ? shallowLayer(serialized.style, layerName) : serialized.style;
					return processStyle(props, serialized, props.theme.modularCssLayers ? layerName : void 0);
				};
			}
			return style$2;
		};
		const muiStyledResolver = (...expressionsInput) => {
			const expressionsHead = [];
			const expressionsBody = expressionsInput.map(transformStyle);
			const expressionsTail = [];
			expressionsHead.push(styleAttachTheme);
			if (componentName && overridesResolver) expressionsTail.push(function styleThemeOverrides(props) {
				const styleOverrides = props.theme.components?.[componentName]?.styleOverrides;
				if (!styleOverrides) return null;
				const resolvedStyleOverrides = {};
				for (const slotKey in styleOverrides) resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey], props.theme.modularCssLayers ? "theme" : void 0);
				return overridesResolver(props, resolvedStyleOverrides);
			});
			if (componentName && !skipVariantsResolver) expressionsTail.push(function styleThemeVariants(props) {
				const themeVariants = props.theme?.components?.[componentName]?.variants;
				if (!themeVariants) return null;
				return processStyleVariants(props, themeVariants, [], props.theme.modularCssLayers ? "theme" : void 0);
			});
			if (!skipSx) expressionsTail.push(styleFunctionSx_default);
			if (Array.isArray(expressionsBody[0])) {
				const inputStrings = expressionsBody.shift();
				const placeholdersHead = new Array(expressionsHead.length).fill("");
				const placeholdersTail = new Array(expressionsTail.length).fill("");
				let outputStrings;
				outputStrings = [
					...placeholdersHead,
					...inputStrings,
					...placeholdersTail
				];
				outputStrings.raw = [
					...placeholdersHead,
					...inputStrings.raw,
					...placeholdersTail
				];
				expressionsHead.unshift(outputStrings);
			}
			const Component = defaultStyledResolver(...[
				...expressionsHead,
				...expressionsBody,
				...expressionsTail
			]);
			if (tag.muiName) Component.muiName = tag.muiName;
			Component.displayName = generateDisplayName(componentName, componentSlot, tag);
			return Component;
		};
		if (defaultStyledResolver.withConfig) muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
		return muiStyledResolver;
	};
	return styled$3;
}
function generateDisplayName(componentName, componentSlot, tag) {
	if (componentName) return `${componentName}${capitalize(componentSlot || "")}`;
	return `Styled(${getDisplayName(tag)})`;
}
function generateStyledLabel(componentName, componentSlot) {
	let label;
	if (componentName) label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`;
	return label;
}
function isObjectEmpty(object) {
	for (const _ in object) return false;
	return true;
}
function isStringTag(tag) {
	return typeof tag === "string" && tag.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(string) {
	if (!string) return string;
	return string.charAt(0).toLowerCase() + string.slice(1);
}

//#endregion
//#region node_modules/@mui/system/esm/styled/styled.js
var styled$1 = createStyled();
var styled_default$1 = styled$1;

//#endregion
//#region node_modules/@mui/system/esm/useThemeProps/useThemeProps.js
function useThemeProps({ props, name, defaultTheme: defaultTheme$2, themeId }) {
	let theme = useTheme_default(defaultTheme$2);
	if (themeId) theme = theme[themeId] || theme;
	return getThemeProps$1({
		theme,
		name,
		props
	});
}

//#endregion
//#region node_modules/@mui/utils/esm/clamp/clamp.js
function clamp(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
	return Math.max(min, Math.min(val, max));
}
var clamp_default = clamp;

//#endregion
//#region node_modules/@mui/system/esm/colorManipulator/colorManipulator.js
/**
* Returns a number whose value is limited to the given range.
* @param {number} value The value to be clamped
* @param {number} min The lower boundary of the output range
* @param {number} max The upper boundary of the output range
* @returns {number} A number in the range [min, max]
*/
function clampWrapper(value, min = 0, max = 1) {
	if (value < min || value > max) console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`);
	return clamp_default(value, min, max);
}
/**
* Converts a color from CSS hex format to CSS rgb format.
* @param {string} color - Hex color, i.e. #nnn or #nnnnnn
* @returns {string} A CSS rgb color string
*/
function hexToRgb(color$1) {
	color$1 = color$1.slice(1);
	const re = new RegExp(`.{1,${color$1.length >= 6 ? 2 : 1}}`, "g");
	let colors = color$1.match(re);
	if (colors && colors[0].length === 1) colors = colors.map((n) => n + n);
	if (color$1.length !== color$1.trim().length) console.error(`MUI: The color: "${color$1}" is invalid. Make sure the color input doesn't contain leading/trailing space.`);
	return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index) => {
		return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
	}).join(", ")})` : "";
}
function intToHex(int) {
	const hex = int.toString(16);
	return hex.length === 1 ? `0${hex}` : hex;
}
/**
* Returns an object with the type and values of a color.
*
* Note: Does not support rgb % values.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @returns {object} - A MUI color object: {type: string, values: number[]}
*/
function decomposeColor(color$1) {
	if (color$1.type) return color$1;
	if (color$1.charAt(0) === "#") return decomposeColor(hexToRgb(color$1));
	const marker = color$1.indexOf("(");
	const type = color$1.substring(0, marker);
	if (![
		"rgb",
		"rgba",
		"hsl",
		"hsla",
		"color"
	].includes(type)) throw new Error(`MUI: Unsupported \`${color$1}\` color.\nThe following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().`);
	let values$1 = color$1.substring(marker + 1, color$1.length - 1);
	let colorSpace;
	if (type === "color") {
		values$1 = values$1.split(" ");
		colorSpace = values$1.shift();
		if (values$1.length === 4 && values$1[3].charAt(0) === "/") values$1[3] = values$1[3].slice(1);
		if (![
			"srgb",
			"display-p3",
			"a98-rgb",
			"prophoto-rgb",
			"rec-2020"
		].includes(colorSpace)) throw new Error(`MUI: unsupported \`${colorSpace}\` color space.\nThe following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.`);
	} else values$1 = values$1.split(",");
	values$1 = values$1.map((value) => parseFloat(value));
	return {
		type,
		values: values$1,
		colorSpace
	};
}
/**
* Returns a channel created from the input color.
*
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @returns {string} - The channel for the color, that can be used in rgba or hsla colors
*/
const colorChannel = (color$1) => {
	const decomposedColor = decomposeColor(color$1);
	return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
};
const private_safeColorChannel = (color$1, warning) => {
	try {
		return colorChannel(color$1);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
};
/**
* Converts a color object with type and values to a string.
* @param {object} color - Decomposed color
* @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla', 'color'
* @param {array} color.values - [n,n,n] or [n,n,n,n]
* @returns {string} A CSS color string
*/
function recomposeColor(color$1) {
	const { type, colorSpace } = color$1;
	let { values: values$1 } = color$1;
	if (type.includes("rgb")) values$1 = values$1.map((n, i) => i < 3 ? parseInt(n, 10) : n);
	else if (type.includes("hsl")) {
		values$1[1] = `${values$1[1]}%`;
		values$1[2] = `${values$1[2]}%`;
	}
	if (type.includes("color")) values$1 = `${colorSpace} ${values$1.join(" ")}`;
	else values$1 = `${values$1.join(", ")}`;
	return `${type}(${values$1})`;
}
/**
* Converts a color from CSS rgb format to CSS hex format.
* @param {string} color - RGB color, i.e. rgb(n, n, n)
* @returns {string} A CSS rgb color string, i.e. #nnnnnn
*/
function rgbToHex(color$1) {
	if (color$1.startsWith("#")) return color$1;
	const { values: values$1 } = decomposeColor(color$1);
	return `#${values$1.map((n, i) => intToHex(i === 3 ? Math.round(255 * n) : n)).join("")}`;
}
/**
* Converts a color from hsl format to rgb format.
* @param {string} color - HSL color values
* @returns {string} rgb color values
*/
function hslToRgb(color$1) {
	color$1 = decomposeColor(color$1);
	const { values: values$1 } = color$1;
	const h = values$1[0];
	const s = values$1[1] / 100;
	const l = values$1[2] / 100;
	const a = s * Math.min(l, 1 - l);
	const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
	let type = "rgb";
	const rgb = [
		Math.round(f(0) * 255),
		Math.round(f(8) * 255),
		Math.round(f(4) * 255)
	];
	if (color$1.type === "hsla") {
		type += "a";
		rgb.push(values$1[3]);
	}
	return recomposeColor({
		type,
		values: rgb
	});
}
/**
* The relative brightness of any point in a color space,
* normalized to 0 for darkest black and 1 for lightest white.
*
* Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @returns {number} The relative brightness of the color in the range 0 - 1
*/
function getLuminance(color$1) {
	color$1 = decomposeColor(color$1);
	let rgb = color$1.type === "hsl" || color$1.type === "hsla" ? decomposeColor(hslToRgb(color$1)).values : color$1.values;
	rgb = rgb.map((val) => {
		if (color$1.type !== "color") val /= 255;
		return val <= .03928 ? val / 12.92 : ((val + .055) / 1.055) ** 2.4;
	});
	return Number((.2126 * rgb[0] + .7152 * rgb[1] + .0722 * rgb[2]).toFixed(3));
}
/**
* Calculates the contrast ratio between two colors.
*
* Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
* @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
* @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
* @returns {number} A contrast ratio value in the range 0 - 21.
*/
function getContrastRatio(foreground, background) {
	const lumA = getLuminance(foreground);
	const lumB = getLuminance(background);
	return (Math.max(lumA, lumB) + .05) / (Math.min(lumA, lumB) + .05);
}
/**
* Sets the absolute transparency of a color.
* Any existing alpha values are overwritten.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} value - value to set the alpha channel to in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function alpha(color$1, value) {
	color$1 = decomposeColor(color$1);
	value = clampWrapper(value);
	if (color$1.type === "rgb" || color$1.type === "hsl") color$1.type += "a";
	if (color$1.type === "color") color$1.values[3] = `/${value}`;
	else color$1.values[3] = value;
	return recomposeColor(color$1);
}
function private_safeAlpha(color$1, value, warning) {
	try {
		return alpha(color$1, value);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}
/**
* Darkens a color.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} coefficient - multiplier in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function darken(color$1, coefficient) {
	color$1 = decomposeColor(color$1);
	coefficient = clampWrapper(coefficient);
	if (color$1.type.includes("hsl")) color$1.values[2] *= 1 - coefficient;
	else if (color$1.type.includes("rgb") || color$1.type.includes("color")) for (let i = 0; i < 3; i += 1) color$1.values[i] *= 1 - coefficient;
	return recomposeColor(color$1);
}
function private_safeDarken(color$1, coefficient, warning) {
	try {
		return darken(color$1, coefficient);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}
/**
* Lightens a color.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} coefficient - multiplier in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function lighten(color$1, coefficient) {
	color$1 = decomposeColor(color$1);
	coefficient = clampWrapper(coefficient);
	if (color$1.type.includes("hsl")) color$1.values[2] += (100 - color$1.values[2]) * coefficient;
	else if (color$1.type.includes("rgb")) for (let i = 0; i < 3; i += 1) color$1.values[i] += (255 - color$1.values[i]) * coefficient;
	else if (color$1.type.includes("color")) for (let i = 0; i < 3; i += 1) color$1.values[i] += (1 - color$1.values[i]) * coefficient;
	return recomposeColor(color$1);
}
function private_safeLighten(color$1, coefficient, warning) {
	try {
		return lighten(color$1, coefficient);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}
/**
* Darken or lighten a color, depending on its luminance.
* Light colors are darkened, dark colors are lightened.
* @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
* @param {number} coefficient=0.15 - multiplier in the range 0 - 1
* @returns {string} A CSS color string. Hex input values are returned as rgb
*/
function emphasize(color$1, coefficient = .15) {
	return getLuminance(color$1) > .5 ? darken(color$1, coefficient) : lighten(color$1, coefficient);
}
function private_safeEmphasize(color$1, coefficient, warning) {
	try {
		return emphasize(color$1, coefficient);
	} catch (error) {
		if (warning && true) console.warn(warning);
		return color$1;
	}
}

//#endregion
//#region node_modules/@mui/utils/esm/exactProp/exactProp.js
var specialProperty = "exact-prop: â€‹";
function exactProp(propTypes) {
	return {
		...propTypes,
		[specialProperty]: (props) => {
			const unsupportedProps = Object.keys(props).filter((prop) => !propTypes.hasOwnProperty(prop));
			if (unsupportedProps.length > 0) return /* @__PURE__ */ new Error(`The following props are not supported: ${unsupportedProps.map((prop) => `\`${prop}\``).join(", ")}. Please remove them.`);
			return null;
		}
	};
}

//#endregion
//#region node_modules/@mui/private-theming/esm/useTheme/ThemeContext.js
var ThemeContext$1 = /* @__PURE__ */ import_react.createContext(null);
ThemeContext$1.displayName = "ThemeContext";
var ThemeContext_default = ThemeContext$1;

//#endregion
//#region node_modules/@mui/private-theming/esm/useTheme/useTheme.js
function useTheme() {
	const theme = import_react.useContext(ThemeContext_default);
	import_react.useDebugValue(theme);
	return theme;
}

//#endregion
//#region node_modules/@mui/private-theming/esm/ThemeProvider/nested.js
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var nested_default = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";

//#endregion
//#region node_modules/@mui/private-theming/esm/ThemeProvider/ThemeProvider.js
var import_prop_types$5 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
function mergeOuterLocalTheme(outerTheme, localTheme) {
	if (typeof localTheme === "function") {
		const mergedTheme = localTheme(outerTheme);
		if (!mergedTheme) console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join("\n"));
		return mergedTheme;
	}
	return {
		...outerTheme,
		...localTheme
	};
}
/**
* This component takes a `theme` prop.
* It makes the `theme` available down the React tree thanks to React context.
* This component should preferably be used at **the root of your component tree**.
*/
function ThemeProvider$1(props) {
	const { children, theme: localTheme } = props;
	const outerTheme = useTheme();
	if (outerTheme === null && typeof localTheme === "function") console.error([
		"MUI: You are providing a theme function prop to the ThemeProvider component:",
		"<ThemeProvider theme={outerTheme => outerTheme} />",
		"",
		"However, no outer theme is present.",
		"Make sure a theme is already injected higher in the React tree or provide a theme object."
	].join("\n"));
	const theme = import_react.useMemo(() => {
		const output = outerTheme === null ? { ...localTheme } : mergeOuterLocalTheme(outerTheme, localTheme);
		if (output != null) output[nested_default] = outerTheme !== null;
		return output;
	}, [localTheme, outerTheme]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ThemeContext_default.Provider, {
		value: theme,
		children
	});
}
ThemeProvider$1.propTypes = {
	children: import_prop_types$5.default.node,
	theme: import_prop_types$5.default.oneOfType([import_prop_types$5.default.object, import_prop_types$5.default.func]).isRequired
};
ThemeProvider$1.propTypes = exactProp(ThemeProvider$1.propTypes);
var ThemeProvider_default$1 = ThemeProvider$1;

//#endregion
//#region node_modules/@mui/system/esm/RtlProvider/index.js
var import_prop_types$4 = /* @__PURE__ */ __toESM(require_prop_types());
var RtlContext = /* @__PURE__ */ import_react.createContext();
function RtlProvider({ value,...props }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RtlContext.Provider, {
		value: value ?? true,
		...props
	});
}
RtlProvider.propTypes = {
	children: import_prop_types$4.default.node,
	value: import_prop_types$4.default.bool
};
const useRtl = () => {
	return import_react.useContext(RtlContext) ?? false;
};
var RtlProvider_default = RtlProvider;

//#endregion
//#region node_modules/@mui/system/esm/DefaultPropsProvider/DefaultPropsProvider.js
var import_prop_types$3 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var PropsContext = /* @__PURE__ */ import_react.createContext(void 0);
function DefaultPropsProvider({ value, children }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PropsContext.Provider, {
		value,
		children
	});
}
DefaultPropsProvider.propTypes = {
	children: import_prop_types$3.default.node,
	value: import_prop_types$3.default.object
};
function getThemeProps(params) {
	const { theme, name, props } = params;
	if (!theme || !theme.components || !theme.components[name]) return props;
	const config = theme.components[name];
	if (config.defaultProps) return resolveProps(config.defaultProps, props, theme.components.mergeClassNameAndStyle);
	if (!config.styleOverrides && !config.variants) return resolveProps(config, props, theme.components.mergeClassNameAndStyle);
	return props;
}
function useDefaultProps({ props, name }) {
	return getThemeProps({
		props,
		name,
		theme: { components: import_react.useContext(PropsContext) }
	});
}
var DefaultPropsProvider_default = DefaultPropsProvider;

//#endregion
//#region node_modules/@mui/utils/esm/useId/useId.js
var globalId = 0;
function useGlobalId(idOverride) {
	const [defaultId, setDefaultId] = import_react.useState(idOverride);
	const id = idOverride || defaultId;
	import_react.useEffect(() => {
		if (defaultId == null) {
			globalId += 1;
			setDefaultId(`mui-${globalId}`);
		}
	}, [defaultId]);
	return id;
}
var maybeReactUseId = { ...import_react }.useId;
/**
*
* @example <div id={useId()} />
* @param idOverride
* @returns {string}
*/
function useId(idOverride) {
	if (maybeReactUseId !== void 0) {
		const reactId = maybeReactUseId();
		return idOverride ?? reactId;
	}
	return useGlobalId(idOverride);
}

//#endregion
//#region node_modules/@mui/system/esm/ThemeProvider/useLayerOrder.js
/**
* This hook returns a `GlobalStyles` component that sets the CSS layer order (for server-side rendering).
* Then on client-side, it injects the CSS layer order into the document head to ensure that the layer order is always present first before other Emotion styles.
*/
function useLayerOrder(theme) {
	const upperTheme = useThemeWithoutDefault_default();
	const id = useId() || "";
	const { modularCssLayers } = theme;
	let layerOrder = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
	if (!modularCssLayers || upperTheme !== null) layerOrder = "";
	else if (typeof modularCssLayers === "string") layerOrder = modularCssLayers.replace(/mui(?!\.)/g, layerOrder);
	else layerOrder = `@layer ${layerOrder};`;
	useEnhancedEffect_default(() => {
		const head = document.querySelector("head");
		if (!head) return;
		const firstChild = head.firstChild;
		if (layerOrder) {
			if (firstChild && firstChild.hasAttribute?.("data-mui-layer-order") && firstChild.getAttribute("data-mui-layer-order") === id) return;
			const styleElement = document.createElement("style");
			styleElement.setAttribute("data-mui-layer-order", id);
			styleElement.textContent = layerOrder;
			head.prepend(styleElement);
		} else head.querySelector(`style[data-mui-layer-order="${id}"]`)?.remove();
	}, [layerOrder, id]);
	if (!layerOrder) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GlobalStyles_default, { styles: layerOrder });
}

//#endregion
//#region node_modules/@mui/system/esm/ThemeProvider/ThemeProvider.js
var import_prop_types$2 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var EMPTY_THEME = {};
function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
	return import_react.useMemo(() => {
		const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
		if (typeof localTheme === "function") {
			const mergedTheme = localTheme(resolvedTheme);
			const result = themeId ? {
				...upperTheme,
				[themeId]: mergedTheme
			} : mergedTheme;
			if (isPrivate) return () => result;
			return result;
		}
		return themeId ? {
			...upperTheme,
			[themeId]: localTheme
		} : {
			...upperTheme,
			...localTheme
		};
	}, [
		themeId,
		upperTheme,
		localTheme,
		isPrivate
	]);
}
/**
* This component makes the `theme` available down the React tree.
* It should preferably be used at **the root of your component tree**.
*
* <ThemeProvider theme={theme}> // existing use case
* <ThemeProvider theme={{ id: theme }}> // theme scoping
*/
function ThemeProvider(props) {
	const { children, theme: localTheme, themeId } = props;
	const upperTheme = useThemeWithoutDefault_default(EMPTY_THEME);
	const upperPrivateTheme = useTheme() || EMPTY_THEME;
	if (upperTheme === null && typeof localTheme === "function" || themeId && upperTheme && !upperTheme[themeId] && typeof localTheme === "function") console.error([
		"MUI: You are providing a theme function prop to the ThemeProvider component:",
		"<ThemeProvider theme={outerTheme => outerTheme} />",
		"",
		"However, no outer theme is present.",
		"Make sure a theme is already injected higher in the React tree or provide a theme object."
	].join("\n"));
	const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
	const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
	const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
	const layerOrder = useLayerOrder(engineTheme);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ThemeProvider_default$1, {
		theme: privateTheme,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ThemeContext.Provider, {
			value: engineTheme,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RtlProvider_default, {
				value: rtlValue,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DefaultPropsProvider_default, {
					value: themeId ? engineTheme[themeId].components : engineTheme.components,
					children: [layerOrder, children]
				})
			})
		})
	});
}
ThemeProvider.propTypes = {
	children: import_prop_types$2.default.node,
	theme: import_prop_types$2.default.oneOfType([import_prop_types$2.default.func, import_prop_types$2.default.object]).isRequired,
	themeId: import_prop_types$2.default.string
};
ThemeProvider.propTypes = exactProp(ThemeProvider.propTypes);
var ThemeProvider_default = ThemeProvider;

//#endregion
//#region node_modules/@mui/system/esm/memoTheme.js
var arg = { theme: void 0 };
/**
* Memoize style function on theme.
* Intended to be used in styled() calls that only need access to the theme.
*/
function unstable_memoTheme(styleFn) {
	let lastValue;
	let lastTheme;
	return function styleMemoized(props) {
		let value = lastValue;
		if (value === void 0 || props.theme !== lastTheme) {
			arg.theme = props.theme;
			value = preprocessStyles(styleFn(arg));
			lastValue = value;
			lastTheme = props.theme;
		}
		return value;
	};
}

//#endregion
//#region node_modules/@mui/system/esm/InitColorSchemeScript/InitColorSchemeScript.js
const DEFAULT_MODE_STORAGE_KEY = "mode";
const DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
const DEFAULT_ATTRIBUTE = "data-color-scheme";
function InitColorSchemeScript(options) {
	const { defaultMode = "system", defaultLightColorScheme = "light", defaultDarkColorScheme = "dark", modeStorageKey = DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY, attribute: initialAttribute = DEFAULT_ATTRIBUTE, colorSchemeNode = "document.documentElement", nonce } = options || {};
	let setter = "";
	let attribute = initialAttribute;
	if (initialAttribute === "class") attribute = ".%s";
	if (initialAttribute === "data") attribute = "[data-%s]";
	if (attribute.startsWith(".")) {
		const selector = attribute.substring(1);
		setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
	}
	const matches = attribute.match(/\[([^[\]]+)\]/);
	if (matches) {
		const [attr, value] = matches[1].split("=");
		if (!value) setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
		setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : "\"\""});`;
	} else setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("script", {
		suppressHydrationWarning: true,
		nonce: typeof window === "undefined" ? nonce : "",
		dangerouslySetInnerHTML: { __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();` }
	}, "mui-color-scheme-init");
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/localStorageManager.js
function noop$1() {}
var localStorageManager = ({ key, storageWindow }) => {
	if (!storageWindow && typeof window !== "undefined") storageWindow = window;
	return {
		get(defaultValue) {
			if (typeof window === "undefined") return;
			if (!storageWindow) return defaultValue;
			let value;
			try {
				value = storageWindow.localStorage.getItem(key);
			} catch {}
			return value || defaultValue;
		},
		set: (value) => {
			if (storageWindow) try {
				storageWindow.localStorage.setItem(key, value);
			} catch {}
		},
		subscribe: (handler) => {
			if (!storageWindow) return noop$1;
			const listener = (event) => {
				const value = event.newValue;
				if (event.key === key) handler(value);
			};
			storageWindow.addEventListener("storage", listener);
			return () => {
				storageWindow.removeEventListener("storage", listener);
			};
		}
	};
};
var localStorageManager_default = localStorageManager;

//#endregion
//#region node_modules/@mui/system/esm/cssVars/useCurrentColorScheme.js
function noop() {}
function getSystemMode(mode) {
	if (typeof window !== "undefined" && typeof window.matchMedia === "function" && mode === "system") {
		if (window.matchMedia("(prefers-color-scheme: dark)").matches) return "dark";
		return "light";
	}
}
function processState(state, callback) {
	if (state.mode === "light" || state.mode === "system" && state.systemMode === "light") return callback("light");
	if (state.mode === "dark" || state.mode === "system" && state.systemMode === "dark") return callback("dark");
}
function getColorScheme(state) {
	return processState(state, (mode) => {
		if (mode === "light") return state.lightColorScheme;
		if (mode === "dark") return state.darkColorScheme;
	});
}
function useCurrentColorScheme(options) {
	const { defaultMode = "light", defaultLightColorScheme, defaultDarkColorScheme, supportedColorSchemes = [], modeStorageKey = DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY, storageWindow = typeof window === "undefined" ? void 0 : window, storageManager = localStorageManager_default, noSsr = false } = options;
	const joinedColorSchemes = supportedColorSchemes.join(",");
	const isMultiSchemes = supportedColorSchemes.length > 1;
	const modeStorage = import_react.useMemo(() => storageManager?.({
		key: modeStorageKey,
		storageWindow
	}), [
		storageManager,
		modeStorageKey,
		storageWindow
	]);
	const lightStorage = import_react.useMemo(() => storageManager?.({
		key: `${colorSchemeStorageKey}-light`,
		storageWindow
	}), [
		storageManager,
		colorSchemeStorageKey,
		storageWindow
	]);
	const darkStorage = import_react.useMemo(() => storageManager?.({
		key: `${colorSchemeStorageKey}-dark`,
		storageWindow
	}), [
		storageManager,
		colorSchemeStorageKey,
		storageWindow
	]);
	const [state, setState] = import_react.useState(() => {
		const initialMode = modeStorage?.get(defaultMode) || defaultMode;
		const lightColorScheme = lightStorage?.get(defaultLightColorScheme) || defaultLightColorScheme;
		const darkColorScheme = darkStorage?.get(defaultDarkColorScheme) || defaultDarkColorScheme;
		return {
			mode: initialMode,
			systemMode: getSystemMode(initialMode),
			lightColorScheme,
			darkColorScheme
		};
	});
	const [isClient, setIsClient] = import_react.useState(noSsr || !isMultiSchemes);
	import_react.useEffect(() => {
		setIsClient(true);
	}, []);
	const colorScheme = getColorScheme(state);
	const setMode = import_react.useCallback((mode) => {
		setState((currentState) => {
			if (mode === currentState.mode) return currentState;
			const newMode = mode ?? defaultMode;
			modeStorage?.set(newMode);
			return {
				...currentState,
				mode: newMode,
				systemMode: getSystemMode(newMode)
			};
		});
	}, [modeStorage, defaultMode]);
	const setColorScheme = import_react.useCallback((value) => {
		if (!value) setState((currentState) => {
			lightStorage?.set(defaultLightColorScheme);
			darkStorage?.set(defaultDarkColorScheme);
			return {
				...currentState,
				lightColorScheme: defaultLightColorScheme,
				darkColorScheme: defaultDarkColorScheme
			};
		});
		else if (typeof value === "string") if (value && !joinedColorSchemes.includes(value)) console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
		else setState((currentState) => {
			const newState = { ...currentState };
			processState(currentState, (mode) => {
				if (mode === "light") {
					lightStorage?.set(value);
					newState.lightColorScheme = value;
				}
				if (mode === "dark") {
					darkStorage?.set(value);
					newState.darkColorScheme = value;
				}
			});
			return newState;
		});
		else setState((currentState) => {
			const newState = { ...currentState };
			const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
			const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
			if (newLightColorScheme) if (!joinedColorSchemes.includes(newLightColorScheme)) console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
			else {
				newState.lightColorScheme = newLightColorScheme;
				lightStorage?.set(newLightColorScheme);
			}
			if (newDarkColorScheme) if (!joinedColorSchemes.includes(newDarkColorScheme)) console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
			else {
				newState.darkColorScheme = newDarkColorScheme;
				darkStorage?.set(newDarkColorScheme);
			}
			return newState;
		});
	}, [
		joinedColorSchemes,
		lightStorage,
		darkStorage,
		defaultLightColorScheme,
		defaultDarkColorScheme
	]);
	const handleMediaQuery = import_react.useCallback((event) => {
		if (state.mode === "system") setState((currentState) => {
			const systemMode = event?.matches ? "dark" : "light";
			if (currentState.systemMode === systemMode) return currentState;
			return {
				...currentState,
				systemMode
			};
		});
	}, [state.mode]);
	const mediaListener = import_react.useRef(handleMediaQuery);
	mediaListener.current = handleMediaQuery;
	import_react.useEffect(() => {
		if (typeof window.matchMedia !== "function" || !isMultiSchemes) return;
		const handler = (...args) => mediaListener.current(...args);
		const media = window.matchMedia("(prefers-color-scheme: dark)");
		media.addListener(handler);
		handler(media);
		return () => {
			media.removeListener(handler);
		};
	}, [isMultiSchemes]);
	import_react.useEffect(() => {
		if (isMultiSchemes) {
			const unsubscribeMode = modeStorage?.subscribe((value) => {
				if (!value || [
					"light",
					"dark",
					"system"
				].includes(value)) setMode(value || defaultMode);
			}) || noop;
			const unsubscribeLight = lightStorage?.subscribe((value) => {
				if (!value || joinedColorSchemes.match(value)) setColorScheme({ light: value });
			}) || noop;
			const unsubscribeDark = darkStorage?.subscribe((value) => {
				if (!value || joinedColorSchemes.match(value)) setColorScheme({ dark: value });
			}) || noop;
			return () => {
				unsubscribeMode();
				unsubscribeLight();
				unsubscribeDark();
			};
		}
	}, [
		setColorScheme,
		setMode,
		joinedColorSchemes,
		defaultMode,
		storageWindow,
		isMultiSchemes,
		modeStorage,
		lightStorage,
		darkStorage
	]);
	return {
		...state,
		mode: isClient ? state.mode : void 0,
		systemMode: isClient ? state.systemMode : void 0,
		colorScheme: isClient ? colorScheme : void 0,
		setMode,
		setColorScheme
	};
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/createCssVarsProvider.js
var import_prop_types$1 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
const DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(options) {
	const { themeId, theme: defaultTheme$2 = {}, modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY, disableTransitionOnChange: designSystemTransitionOnChange = false, defaultColorScheme, resolveTheme } = options;
	const defaultContext = {
		allColorSchemes: [],
		colorScheme: void 0,
		darkColorScheme: void 0,
		lightColorScheme: void 0,
		mode: void 0,
		setColorScheme: () => {},
		setMode: () => {},
		systemMode: void 0
	};
	const ColorSchemeContext = /* @__PURE__ */ import_react.createContext(void 0);
	ColorSchemeContext.displayName = "ColorSchemeContext";
	const useColorScheme = () => import_react.useContext(ColorSchemeContext) || defaultContext;
	const defaultColorSchemes = {};
	const defaultComponents = {};
	function CssVarsProvider(props) {
		const { children, theme: themeProp, modeStorageKey = defaultModeStorageKey, colorSchemeStorageKey = defaultColorSchemeStorageKey, disableTransitionOnChange = designSystemTransitionOnChange, storageManager, storageWindow = typeof window === "undefined" ? void 0 : window, documentNode = typeof document === "undefined" ? void 0 : document, colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement, disableNestedContext = false, disableStyleSheetGeneration = false, defaultMode: initialMode = "system", forceThemeRerender = false, noSsr } = props;
		const hasMounted = import_react.useRef(false);
		const upperTheme = useTheme();
		const ctx = import_react.useContext(ColorSchemeContext);
		const nested = !!ctx && !disableNestedContext;
		const initialTheme = import_react.useMemo(() => {
			if (themeProp) return themeProp;
			return typeof defaultTheme$2 === "function" ? defaultTheme$2() : defaultTheme$2;
		}, [themeProp]);
		const scopedTheme = initialTheme[themeId];
		const restThemeProp = scopedTheme || initialTheme;
		const { colorSchemes = defaultColorSchemes, components = defaultComponents, cssVarPrefix } = restThemeProp;
		const joinedColorSchemes = Object.keys(colorSchemes).filter((k) => !!colorSchemes[k]).join(",");
		const allColorSchemes = import_react.useMemo(() => joinedColorSchemes.split(","), [joinedColorSchemes]);
		const defaultLightColorScheme$1 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
		const defaultDarkColorScheme$1 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
		const { mode: stateMode, setMode, systemMode, lightColorScheme, darkColorScheme, colorScheme: stateColorScheme, setColorScheme } = useCurrentColorScheme({
			supportedColorSchemes: allColorSchemes,
			defaultLightColorScheme: defaultLightColorScheme$1,
			defaultDarkColorScheme: defaultDarkColorScheme$1,
			modeStorageKey,
			colorSchemeStorageKey,
			defaultMode: colorSchemes[defaultLightColorScheme$1] && colorSchemes[defaultDarkColorScheme$1] ? initialMode : colorSchemes[restThemeProp.defaultColorScheme]?.palette?.mode || restThemeProp.palette?.mode,
			storageManager,
			storageWindow,
			noSsr
		});
		let mode = stateMode;
		let colorScheme = stateColorScheme;
		if (nested) {
			mode = ctx.mode;
			colorScheme = ctx.colorScheme;
		}
		if (forceThemeRerender && !restThemeProp.vars) console.warn(["MUI: The `forceThemeRerender` prop should only be used with CSS theme variables.", "Note that it will slow down the app when changing between modes, so only do this when you cannot find a better solution."].join("\n"));
		let calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
		if (restThemeProp.vars && !forceThemeRerender) calculatedColorScheme = restThemeProp.defaultColorScheme;
		const memoTheme = import_react.useMemo(() => {
			const themeVars = restThemeProp.generateThemeVars?.() || restThemeProp.vars;
			const theme = {
				...restThemeProp,
				components,
				colorSchemes,
				cssVarPrefix,
				vars: themeVars
			};
			if (typeof theme.generateSpacing === "function") theme.spacing = theme.generateSpacing();
			if (calculatedColorScheme) {
				const scheme = colorSchemes[calculatedColorScheme];
				if (scheme && typeof scheme === "object") Object.keys(scheme).forEach((schemeKey) => {
					if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") theme[schemeKey] = {
						...theme[schemeKey],
						...scheme[schemeKey]
					};
					else theme[schemeKey] = scheme[schemeKey];
				});
			}
			return resolveTheme ? resolveTheme(theme) : theme;
		}, [
			restThemeProp,
			calculatedColorScheme,
			components,
			colorSchemes,
			cssVarPrefix
		]);
		const colorSchemeSelector = restThemeProp.colorSchemeSelector;
		useEnhancedEffect_default(() => {
			if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
				const selector = colorSchemeSelector;
				let rule = colorSchemeSelector;
				if (selector === "class") rule = `.%s`;
				if (selector === "data") rule = `[data-%s]`;
				if (selector?.startsWith("data-") && !selector.includes("%s")) rule = `[${selector}="%s"]`;
				if (rule.startsWith(".")) {
					colorSchemeNode.classList.remove(...allColorSchemes.map((scheme) => rule.substring(1).replace("%s", scheme)));
					colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
				} else {
					const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
					if (matches) {
						const [attr, value] = matches[1].split("=");
						if (!value) allColorSchemes.forEach((scheme) => {
							colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
						});
						colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
					} else colorSchemeNode.setAttribute(rule, colorScheme);
				}
			}
		}, [
			colorScheme,
			colorSchemeSelector,
			colorSchemeNode,
			allColorSchemes
		]);
		import_react.useEffect(() => {
			let timer;
			if (disableTransitionOnChange && hasMounted.current && documentNode) {
				const css$1 = documentNode.createElement("style");
				css$1.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
				documentNode.head.appendChild(css$1);
				window.getComputedStyle(documentNode.body);
				timer = setTimeout(() => {
					documentNode.head.removeChild(css$1);
				}, 1);
			}
			return () => {
				clearTimeout(timer);
			};
		}, [
			colorScheme,
			disableTransitionOnChange,
			documentNode
		]);
		import_react.useEffect(() => {
			hasMounted.current = true;
			return () => {
				hasMounted.current = false;
			};
		}, []);
		const contextValue = import_react.useMemo(() => ({
			allColorSchemes,
			colorScheme,
			darkColorScheme,
			lightColorScheme,
			mode,
			setColorScheme,
			setMode: (newMode) => {
				if (memoTheme.colorSchemeSelector === "media") console.error([
					"MUI: The `setMode` function has no effect if `colorSchemeSelector` is `media` (`media` is the default value).",
					"To toggle the mode manually, please configure `colorSchemeSelector` to use a class or data attribute.",
					"To learn more, visit https://mui.com/material-ui/customization/css-theme-variables/configuration/#toggling-dark-mode-manually"
				].join("\n"));
				setMode(newMode);
			},
			systemMode
		}), [
			allColorSchemes,
			colorScheme,
			darkColorScheme,
			lightColorScheme,
			mode,
			setColorScheme,
			setMode,
			systemMode,
			memoTheme.colorSchemeSelector
		]);
		let shouldGenerateStyleSheet = true;
		if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested && upperTheme?.cssVarPrefix === cssVarPrefix) shouldGenerateStyleSheet = false;
		const element = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_react.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ThemeProvider_default, {
			themeId: scopedTheme ? themeId : void 0,
			theme: memoTheme,
			children
		}), shouldGenerateStyleSheet && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(GlobalStyles, { styles: memoTheme.generateStyleSheets?.() || [] })] });
		if (nested) return element;
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ColorSchemeContext.Provider, {
			value: contextValue,
			children: element
		});
	}
	CssVarsProvider.propTypes = {
		children: import_prop_types$1.default.node,
		colorSchemeNode: import_prop_types$1.default.any,
		colorSchemeStorageKey: import_prop_types$1.default.string,
		defaultMode: import_prop_types$1.default.string,
		disableNestedContext: import_prop_types$1.default.bool,
		disableStyleSheetGeneration: import_prop_types$1.default.bool,
		disableTransitionOnChange: import_prop_types$1.default.bool,
		documentNode: import_prop_types$1.default.any,
		forceThemeRerender: import_prop_types$1.default.bool,
		modeStorageKey: import_prop_types$1.default.string,
		noSsr: import_prop_types$1.default.bool,
		storageManager: import_prop_types$1.default.func,
		storageWindow: import_prop_types$1.default.any,
		theme: import_prop_types$1.default.object
	};
	const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
	const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
	const getInitColorSchemeScript = (params) => InitColorSchemeScript({
		colorSchemeStorageKey: defaultColorSchemeStorageKey,
		defaultLightColorScheme,
		defaultDarkColorScheme,
		modeStorageKey: defaultModeStorageKey,
		...params
	});
	return {
		CssVarsProvider,
		useColorScheme,
		getInitColorSchemeScript
	};
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/createGetCssVar.js
/**
* The benefit of this function is to help developers get CSS var from theme without specifying the whole variable
* and they does not need to remember the prefix (defined once).
*/
function createGetCssVar(prefix = "") {
	function appendVar(...vars) {
		if (!vars.length) return "";
		const value = vars[0];
		if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) return `, var(--${prefix ? `${prefix}-` : ""}${value}${appendVar(...vars.slice(1))})`;
		return `, ${value}`;
	}
	const getCssVar = (field, ...fallbacks) => {
		return `var(--${prefix ? `${prefix}-` : ""}${field}${appendVar(...fallbacks)})`;
	};
	return getCssVar;
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/cssVarsParser.js
/**
* This function create an object from keys, value and then assign to target
*
* @param {Object} obj : the target object to be assigned
* @param {string[]} keys
* @param {string | number} value
*
* @example
* const source = {}
* assignNestedKeys(source, ['palette', 'primary'], 'var(--palette-primary)')
* console.log(source) // { palette: { primary: 'var(--palette-primary)' } }
*
* @example
* const source = { palette: { primary: 'var(--palette-primary)' } }
* assignNestedKeys(source, ['palette', 'secondary'], 'var(--palette-secondary)')
* console.log(source) // { palette: { primary: 'var(--palette-primary)', secondary: 'var(--palette-secondary)' } }
*/
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
	let temp = obj;
	keys.forEach((k, index) => {
		if (index === keys.length - 1) {
			if (Array.isArray(temp)) temp[Number(k)] = value;
			else if (temp && typeof temp === "object") temp[k] = value;
		} else if (temp && typeof temp === "object") {
			if (!temp[k]) temp[k] = arrayKeys.includes(k) ? [] : {};
			temp = temp[k];
		}
	});
};
/**
*
* @param {Object} obj : source object
* @param {Function} callback : a function that will be called when
*                   - the deepest key in source object is reached
*                   - the value of the deepest key is NOT `undefined` | `null`
*
* @example
* walkObjectDeep({ palette: { primary: { main: '#000000' } } }, console.log)
* // ['palette', 'primary', 'main'] '#000000'
*/
const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
	function recurse(object, parentKeys = [], arrayKeys = []) {
		Object.entries(object).forEach(([key, value]) => {
			if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
				if (value !== void 0 && value !== null) if (typeof value === "object" && Object.keys(value).length > 0) recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
				else callback([...parentKeys, key], value, arrayKeys);
			}
		});
	}
	recurse(obj);
};
var getCssValue = (keys, value) => {
	if (typeof value === "number") {
		if ([
			"lineHeight",
			"fontWeight",
			"opacity",
			"zIndex"
		].some((prop) => keys.includes(prop))) return value;
		if (keys[keys.length - 1].toLowerCase().includes("opacity")) return value;
		return `${value}px`;
	}
	return value;
};
/**
* a function that parse theme and return { css, vars }
*
* @param {Object} theme
* @param {{
*  prefix?: string,
*  shouldSkipGeneratingVar?: (objectPathKeys: Array<string>, value: string | number) => boolean
* }} options.
*  `prefix`: The prefix of the generated CSS variables. This function does not change the value.
*
* @returns {{ css: Object, vars: Object }} `css` is the stylesheet, `vars` is an object to get css variable (same structure as theme).
*
* @example
* const { css, vars } = parser({
*   fontSize: 12,
*   lineHeight: 1.2,
*   palette: { primary: { 500: 'var(--color)' } }
* }, { prefix: 'foo' })
*
* console.log(css) // { '--foo-fontSize': '12px', '--foo-lineHeight': 1.2, '--foo-palette-primary-500': 'var(--color)' }
* console.log(vars) // { fontSize: 'var(--foo-fontSize)', lineHeight: 'var(--foo-lineHeight)', palette: { primary: { 500: 'var(--foo-palette-primary-500)' } } }
*/
function cssVarsParser(theme, options) {
	const { prefix, shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 } = options || {};
	const css$1 = {};
	const vars = {};
	const varsWithDefaults = {};
	walkObjectDeep(theme, (keys, value, arrayKeys) => {
		if (typeof value === "string" || typeof value === "number") {
			if (!shouldSkipGeneratingVar$1 || !shouldSkipGeneratingVar$1(keys, value)) {
				const cssVar = `--${prefix ? `${prefix}-` : ""}${keys.join("-")}`;
				const resolvedValue = getCssValue(keys, value);
				Object.assign(css$1, { [cssVar]: resolvedValue });
				assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
				assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
			}
		}
	}, (keys) => keys[0] === "vars");
	return {
		css: css$1,
		vars,
		varsWithDefaults
	};
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/prepareCssVars.js
function prepareCssVars(theme, parserConfig = {}) {
	const { getSelector = defaultGetSelector, disableCssColorScheme, colorSchemeSelector: selector, enableContrastVars } = parserConfig;
	const { colorSchemes = {}, components, defaultColorScheme = "light",...otherTheme } = theme;
	const { vars: rootVars, css: rootCss, varsWithDefaults: rootVarsWithDefaults } = cssVarsParser(otherTheme, parserConfig);
	let themeVars = rootVarsWithDefaults;
	const colorSchemesMap = {};
	const { [defaultColorScheme]: defaultScheme,...otherColorSchemes } = colorSchemes;
	Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
		const { vars, css: css$1, varsWithDefaults } = cssVarsParser(scheme, parserConfig);
		themeVars = deepmerge(themeVars, varsWithDefaults);
		colorSchemesMap[key] = {
			css: css$1,
			vars
		};
	});
	if (defaultScheme) {
		const { css: css$1, vars, varsWithDefaults } = cssVarsParser(defaultScheme, parserConfig);
		themeVars = deepmerge(themeVars, varsWithDefaults);
		colorSchemesMap[defaultColorScheme] = {
			css: css$1,
			vars
		};
	}
	function defaultGetSelector(colorScheme, cssObject) {
		let rule = selector;
		if (selector === "class") rule = ".%s";
		if (selector === "data") rule = "[data-%s]";
		if (selector?.startsWith("data-") && !selector.includes("%s")) rule = `[${selector}="%s"]`;
		if (colorScheme) {
			if (rule === "media") {
				if (theme.defaultColorScheme === colorScheme) return ":root";
				return { [`@media (prefers-color-scheme: ${colorSchemes[colorScheme]?.palette?.mode || colorScheme})`]: { ":root": cssObject } };
			}
			if (rule) {
				if (theme.defaultColorScheme === colorScheme) return `:root, ${rule.replace("%s", String(colorScheme))}`;
				return rule.replace("%s", String(colorScheme));
			}
		}
		return ":root";
	}
	const generateThemeVars = () => {
		let vars = { ...rootVars };
		Object.entries(colorSchemesMap).forEach(([, { vars: schemeVars }]) => {
			vars = deepmerge(vars, schemeVars);
		});
		return vars;
	};
	const generateStyleSheets = () => {
		const stylesheets = [];
		const colorScheme = theme.defaultColorScheme || "light";
		function insertStyleSheet(key, css$1) {
			if (Object.keys(css$1).length) stylesheets.push(typeof key === "string" ? { [key]: { ...css$1 } } : key);
		}
		insertStyleSheet(getSelector(void 0, { ...rootCss }), rootCss);
		const { [colorScheme]: defaultSchemeVal,...other } = colorSchemesMap;
		if (defaultSchemeVal) {
			const { css: css$1 } = defaultSchemeVal;
			const cssColorSheme = colorSchemes[colorScheme]?.palette?.mode;
			const finalCss = !disableCssColorScheme && cssColorSheme ? {
				colorScheme: cssColorSheme,
				...css$1
			} : { ...css$1 };
			insertStyleSheet(getSelector(colorScheme, { ...finalCss }), finalCss);
		}
		Object.entries(other).forEach(([key, { css: css$1 }]) => {
			const cssColorSheme = colorSchemes[key]?.palette?.mode;
			const finalCss = !disableCssColorScheme && cssColorSheme ? {
				colorScheme: cssColorSheme,
				...css$1
			} : { ...css$1 };
			insertStyleSheet(getSelector(key, { ...finalCss }), finalCss);
		});
		if (enableContrastVars) stylesheets.push({ ":root": {
			"--__l-threshold": "0.7",
			"--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
			"--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
		} });
		return stylesheets;
	};
	return {
		vars: themeVars,
		generateThemeVars,
		generateStyleSheets
	};
}
var prepareCssVars_default = prepareCssVars;

//#endregion
//#region node_modules/@mui/system/esm/cssVars/getColorSchemeSelector.js
function createGetColorSchemeSelector(selector) {
	return function getColorSchemeSelector(colorScheme) {
		if (selector === "media") {
			if (colorScheme !== "light" && colorScheme !== "dark") console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${colorScheme}'.`);
			return `@media (prefers-color-scheme: ${colorScheme})`;
		}
		if (selector) {
			if (selector.startsWith("data-") && !selector.includes("%s")) return `[${selector}="${colorScheme}"] &`;
			if (selector === "class") return `.${colorScheme} &`;
			if (selector === "data") return `[data-${colorScheme}] &`;
			return `${selector.replace("%s", colorScheme)} &`;
		}
		return "&";
	};
}

//#endregion
//#region node_modules/@mui/system/esm/Container/createContainer.js
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var defaultTheme$1 = createTheme_default();
var defaultCreateStyledComponent = styled_default$1("div", {
	name: "MuiContainer",
	slot: "Root",
	overridesResolver: (props, styles) => {
		const { ownerState } = props;
		return [
			styles.root,
			styles[`maxWidth${capitalize(String(ownerState.maxWidth))}`],
			ownerState.fixed && styles.fixed,
			ownerState.disableGutters && styles.disableGutters
		];
	}
});
var useThemePropsDefault = (inProps) => useThemeProps({
	props: inProps,
	name: "MuiContainer",
	defaultTheme: defaultTheme$1
});
var useUtilityClasses = (ownerState, componentName) => {
	const getContainerUtilityClass = (slot) => {
		return generateUtilityClass(componentName, slot);
	};
	const { classes, fixed, disableGutters, maxWidth: maxWidth$1 } = ownerState;
	return composeClasses({ root: [
		"root",
		maxWidth$1 && `maxWidth${capitalize(String(maxWidth$1))}`,
		fixed && "fixed",
		disableGutters && "disableGutters"
	] }, getContainerUtilityClass, classes);
};
function createContainer(options = {}) {
	const { createStyledComponent = defaultCreateStyledComponent, useThemeProps: useThemeProps$1 = useThemePropsDefault, componentName = "MuiContainer" } = options;
	const ContainerRoot = createStyledComponent(({ theme, ownerState }) => ({
		width: "100%",
		marginLeft: "auto",
		boxSizing: "border-box",
		marginRight: "auto",
		...!ownerState.disableGutters && {
			paddingLeft: theme.spacing(2),
			paddingRight: theme.spacing(2),
			[theme.breakpoints.up("sm")]: {
				paddingLeft: theme.spacing(3),
				paddingRight: theme.spacing(3)
			}
		}
	}), ({ theme, ownerState }) => ownerState.fixed && Object.keys(theme.breakpoints.values).reduce((acc, breakpointValueKey) => {
		const breakpoint = breakpointValueKey;
		const value = theme.breakpoints.values[breakpoint];
		if (value !== 0) acc[theme.breakpoints.up(breakpoint)] = { maxWidth: `${value}${theme.breakpoints.unit}` };
		return acc;
	}, {}), ({ theme, ownerState }) => ({
		...ownerState.maxWidth === "xs" && { [theme.breakpoints.up("xs")]: { maxWidth: Math.max(theme.breakpoints.values.xs, 444) } },
		...ownerState.maxWidth && ownerState.maxWidth !== "xs" && { [theme.breakpoints.up(ownerState.maxWidth)]: { maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}` } }
	}));
	const Container = /* @__PURE__ */ import_react.forwardRef(function Container$1(inProps, ref) {
		const props = useThemeProps$1(inProps);
		const { className, component = "div", disableGutters = false, fixed = false, maxWidth: maxWidth$1 = "lg", classes: classesProp,...other } = props;
		const ownerState = {
			...props,
			component,
			disableGutters,
			fixed,
			maxWidth: maxWidth$1
		};
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ContainerRoot, {
			as: component,
			ownerState,
			className: clsx_default(useUtilityClasses(ownerState, componentName).root, className),
			ref,
			...other
		});
	});
	Container.propTypes = {
		children: import_prop_types.default.node,
		classes: import_prop_types.default.object,
		className: import_prop_types.default.string,
		component: import_prop_types.default.elementType,
		disableGutters: import_prop_types.default.bool,
		fixed: import_prop_types.default.bool,
		maxWidth: import_prop_types.default.oneOfType([import_prop_types.default.oneOf([
			"xs",
			"sm",
			"md",
			"lg",
			"xl",
			false
		]), import_prop_types.default.string]),
		sx: import_prop_types.default.oneOfType([
			import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([
				import_prop_types.default.func,
				import_prop_types.default.object,
				import_prop_types.default.bool
			])),
			import_prop_types.default.func,
			import_prop_types.default.object
		])
	};
	return Container;
}

//#endregion
//#region node_modules/@mui/material/esm/colors/common.js
var common = {
	black: "#000",
	white: "#fff"
};
var common_default = common;

//#endregion
//#region node_modules/@mui/material/esm/colors/grey.js
var grey = {
	50: "#fafafa",
	100: "#f5f5f5",
	200: "#eeeeee",
	300: "#e0e0e0",
	400: "#bdbdbd",
	500: "#9e9e9e",
	600: "#757575",
	700: "#616161",
	800: "#424242",
	900: "#212121",
	A100: "#f5f5f5",
	A200: "#eeeeee",
	A400: "#bdbdbd",
	A700: "#616161"
};
var grey_default = grey;

//#endregion
//#region node_modules/@mui/material/esm/colors/purple.js
var purple = {
	50: "#f3e5f5",
	100: "#e1bee7",
	200: "#ce93d8",
	300: "#ba68c8",
	400: "#ab47bc",
	500: "#9c27b0",
	600: "#8e24aa",
	700: "#7b1fa2",
	800: "#6a1b9a",
	900: "#4a148c",
	A100: "#ea80fc",
	A200: "#e040fb",
	A400: "#d500f9",
	A700: "#aa00ff"
};
var purple_default = purple;

//#endregion
//#region node_modules/@mui/material/esm/colors/red.js
var red = {
	50: "#ffebee",
	100: "#ffcdd2",
	200: "#ef9a9a",
	300: "#e57373",
	400: "#ef5350",
	500: "#f44336",
	600: "#e53935",
	700: "#d32f2f",
	800: "#c62828",
	900: "#b71c1c",
	A100: "#ff8a80",
	A200: "#ff5252",
	A400: "#ff1744",
	A700: "#d50000"
};
var red_default = red;

//#endregion
//#region node_modules/@mui/material/esm/colors/orange.js
var orange = {
	50: "#fff3e0",
	100: "#ffe0b2",
	200: "#ffcc80",
	300: "#ffb74d",
	400: "#ffa726",
	500: "#ff9800",
	600: "#fb8c00",
	700: "#f57c00",
	800: "#ef6c00",
	900: "#e65100",
	A100: "#ffd180",
	A200: "#ffab40",
	A400: "#ff9100",
	A700: "#ff6d00"
};
var orange_default = orange;

//#endregion
//#region node_modules/@mui/material/esm/colors/blue.js
var blue = {
	50: "#e3f2fd",
	100: "#bbdefb",
	200: "#90caf9",
	300: "#64b5f6",
	400: "#42a5f5",
	500: "#2196f3",
	600: "#1e88e5",
	700: "#1976d2",
	800: "#1565c0",
	900: "#0d47a1",
	A100: "#82b1ff",
	A200: "#448aff",
	A400: "#2979ff",
	A700: "#2962ff"
};
var blue_default = blue;

//#endregion
//#region node_modules/@mui/material/esm/colors/lightBlue.js
var lightBlue = {
	50: "#e1f5fe",
	100: "#b3e5fc",
	200: "#81d4fa",
	300: "#4fc3f7",
	400: "#29b6f6",
	500: "#03a9f4",
	600: "#039be5",
	700: "#0288d1",
	800: "#0277bd",
	900: "#01579b",
	A100: "#80d8ff",
	A200: "#40c4ff",
	A400: "#00b0ff",
	A700: "#0091ea"
};
var lightBlue_default = lightBlue;

//#endregion
//#region node_modules/@mui/material/esm/colors/green.js
var green = {
	50: "#e8f5e9",
	100: "#c8e6c9",
	200: "#a5d6a7",
	300: "#81c784",
	400: "#66bb6a",
	500: "#4caf50",
	600: "#43a047",
	700: "#388e3c",
	800: "#2e7d32",
	900: "#1b5e20",
	A100: "#b9f6ca",
	A200: "#69f0ae",
	A400: "#00e676",
	A700: "#00c853"
};
var green_default = green;

//#endregion
//#region node_modules/@mui/material/esm/styles/createPalette.js
function getLight() {
	return {
		text: {
			primary: "rgba(0, 0, 0, 0.87)",
			secondary: "rgba(0, 0, 0, 0.6)",
			disabled: "rgba(0, 0, 0, 0.38)"
		},
		divider: "rgba(0, 0, 0, 0.12)",
		background: {
			paper: common_default.white,
			default: common_default.white
		},
		action: {
			active: "rgba(0, 0, 0, 0.54)",
			hover: "rgba(0, 0, 0, 0.04)",
			hoverOpacity: .04,
			selected: "rgba(0, 0, 0, 0.08)",
			selectedOpacity: .08,
			disabled: "rgba(0, 0, 0, 0.26)",
			disabledBackground: "rgba(0, 0, 0, 0.12)",
			disabledOpacity: .38,
			focus: "rgba(0, 0, 0, 0.12)",
			focusOpacity: .12,
			activatedOpacity: .12
		}
	};
}
const light = getLight();
function getDark() {
	return {
		text: {
			primary: common_default.white,
			secondary: "rgba(255, 255, 255, 0.7)",
			disabled: "rgba(255, 255, 255, 0.5)",
			icon: "rgba(255, 255, 255, 0.5)"
		},
		divider: "rgba(255, 255, 255, 0.12)",
		background: {
			paper: "#121212",
			default: "#121212"
		},
		action: {
			active: common_default.white,
			hover: "rgba(255, 255, 255, 0.08)",
			hoverOpacity: .08,
			selected: "rgba(255, 255, 255, 0.16)",
			selectedOpacity: .16,
			disabled: "rgba(255, 255, 255, 0.3)",
			disabledBackground: "rgba(255, 255, 255, 0.12)",
			disabledOpacity: .38,
			focus: "rgba(255, 255, 255, 0.12)",
			focusOpacity: .12,
			activatedOpacity: .24
		}
	};
}
const dark = getDark();
function addLightOrDark(intent, direction, shade, tonalOffset) {
	const tonalOffsetLight = tonalOffset.light || tonalOffset;
	const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
	if (!intent[direction]) {
		if (intent.hasOwnProperty(shade)) intent[direction] = intent[shade];
		else if (direction === "light") intent.light = lighten(intent.main, tonalOffsetLight);
		else if (direction === "dark") intent.dark = darken(intent.main, tonalOffsetDark);
	}
}
function mixLightOrDark(colorSpace, intent, direction, shade, tonalOffset) {
	const tonalOffsetLight = tonalOffset.light || tonalOffset;
	const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
	if (!intent[direction]) {
		if (intent.hasOwnProperty(shade)) intent[direction] = intent[shade];
		else if (direction === "light") intent.light = `color-mix(in ${colorSpace}, ${intent.main}, #fff ${(tonalOffsetLight * 100).toFixed(0)}%)`;
		else if (direction === "dark") intent.dark = `color-mix(in ${colorSpace}, ${intent.main}, #000 ${(tonalOffsetDark * 100).toFixed(0)}%)`;
	}
}
function getDefaultPrimary(mode = "light") {
	if (mode === "dark") return {
		main: blue_default[200],
		light: blue_default[50],
		dark: blue_default[400]
	};
	return {
		main: blue_default[700],
		light: blue_default[400],
		dark: blue_default[800]
	};
}
function getDefaultSecondary(mode = "light") {
	if (mode === "dark") return {
		main: purple_default[200],
		light: purple_default[50],
		dark: purple_default[400]
	};
	return {
		main: purple_default[500],
		light: purple_default[300],
		dark: purple_default[700]
	};
}
function getDefaultError(mode = "light") {
	if (mode === "dark") return {
		main: red_default[500],
		light: red_default[300],
		dark: red_default[700]
	};
	return {
		main: red_default[700],
		light: red_default[400],
		dark: red_default[800]
	};
}
function getDefaultInfo(mode = "light") {
	if (mode === "dark") return {
		main: lightBlue_default[400],
		light: lightBlue_default[300],
		dark: lightBlue_default[700]
	};
	return {
		main: lightBlue_default[700],
		light: lightBlue_default[500],
		dark: lightBlue_default[900]
	};
}
function getDefaultSuccess(mode = "light") {
	if (mode === "dark") return {
		main: green_default[400],
		light: green_default[300],
		dark: green_default[700]
	};
	return {
		main: green_default[800],
		light: green_default[500],
		dark: green_default[900]
	};
}
function getDefaultWarning(mode = "light") {
	if (mode === "dark") return {
		main: orange_default[400],
		light: orange_default[300],
		dark: orange_default[700]
	};
	return {
		main: "#ed6c02",
		light: orange_default[500],
		dark: orange_default[900]
	};
}
function contrastColor(background) {
	return `oklch(from ${background} var(--__l) 0 h / var(--__a))`;
}
function createPalette(palette$1) {
	const { mode = "light", contrastThreshold = 3, tonalOffset = .2, colorSpace,...other } = palette$1;
	const primary = palette$1.primary || getDefaultPrimary(mode);
	const secondary = palette$1.secondary || getDefaultSecondary(mode);
	const error = palette$1.error || getDefaultError(mode);
	const info = palette$1.info || getDefaultInfo(mode);
	const success = palette$1.success || getDefaultSuccess(mode);
	const warning = palette$1.warning || getDefaultWarning(mode);
	function getContrastText(background) {
		if (colorSpace) return contrastColor(background);
		const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
		{
			const contrast = getContrastRatio(background, contrastText);
			if (contrast < 3) console.error([
				`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`,
				"falls below the WCAG recommended absolute minimum contrast ratio of 3:1.",
				"https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"
			].join("\n"));
		}
		return contrastText;
	}
	const augmentColor = ({ color: color$1, name, mainShade = 500, lightShade = 300, darkShade = 700 }) => {
		color$1 = { ...color$1 };
		if (!color$1.main && color$1[mainShade]) color$1.main = color$1[mainShade];
		if (!color$1.hasOwnProperty("main")) throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.\nThe color object needs to have a \`main\` property or a \`${mainShade}\` property.`);
		if (typeof color$1.main !== "string") throw new Error(`MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.\n\`color.main\` should be a string, but \`${JSON.stringify(color$1.main)}\` was provided instead.\n
Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });`);
		if (colorSpace) {
			mixLightOrDark(colorSpace, color$1, "light", lightShade, tonalOffset);
			mixLightOrDark(colorSpace, color$1, "dark", darkShade, tonalOffset);
		} else {
			addLightOrDark(color$1, "light", lightShade, tonalOffset);
			addLightOrDark(color$1, "dark", darkShade, tonalOffset);
		}
		if (!color$1.contrastText) color$1.contrastText = getContrastText(color$1.main);
		return color$1;
	};
	let modeHydrated;
	if (mode === "light") modeHydrated = getLight();
	else if (mode === "dark") modeHydrated = getDark();
	if (!modeHydrated) console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
	return deepmerge({
		common: { ...common_default },
		mode,
		primary: augmentColor({
			color: primary,
			name: "primary"
		}),
		secondary: augmentColor({
			color: secondary,
			name: "secondary",
			mainShade: "A400",
			lightShade: "A200",
			darkShade: "A700"
		}),
		error: augmentColor({
			color: error,
			name: "error"
		}),
		warning: augmentColor({
			color: warning,
			name: "warning"
		}),
		info: augmentColor({
			color: info,
			name: "info"
		}),
		success: augmentColor({
			color: success,
			name: "success"
		}),
		grey: grey_default,
		contrastThreshold,
		getContrastText,
		augmentColor,
		tonalOffset,
		...modeHydrated
	}, other);
}

//#endregion
//#region node_modules/@mui/system/esm/cssVars/prepareTypographyVars.js
function prepareTypographyVars(typography) {
	const vars = {};
	Object.entries(typography).forEach((entry) => {
		const [key, value] = entry;
		if (typeof value === "object") vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
	});
	return vars;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createMixins.js
function createMixins(breakpoints, mixins) {
	return {
		toolbar: {
			minHeight: 56,
			[breakpoints.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } },
			[breakpoints.up("sm")]: { minHeight: 64 }
		},
		...mixins
	};
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createTypography.js
function round(value) {
	return Math.round(value * 1e5) / 1e5;
}
var caseAllCaps = { textTransform: "uppercase" };
var defaultFontFamily = "\"Roboto\", \"Helvetica\", \"Arial\", sans-serif";
/**
* @see @link{https://m2.material.io/design/typography/the-type-system.html}
* @see @link{https://m2.material.io/design/typography/understanding-typography.html}
*/
function createTypography(palette$1, typography) {
	const { fontFamily = defaultFontFamily, fontSize = 14, fontWeightLight = 300, fontWeightRegular = 400, fontWeightMedium = 500, fontWeightBold = 700, htmlFontSize = 16, allVariants, pxToRem: pxToRem2,...other } = typeof typography === "function" ? typography(palette$1) : typography;
	if (typeof fontSize !== "number") console.error("MUI: `fontSize` is required to be a number.");
	if (typeof htmlFontSize !== "number") console.error("MUI: `htmlFontSize` is required to be a number.");
	const coef = fontSize / 14;
	const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
	const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => ({
		fontFamily,
		fontWeight,
		fontSize: pxToRem(size),
		lineHeight,
		...fontFamily === defaultFontFamily ? { letterSpacing: `${round(letterSpacing / size)}em` } : {},
		...casing,
		...allVariants
	});
	return deepmerge({
		htmlFontSize,
		pxToRem,
		fontFamily,
		fontSize,
		fontWeightLight,
		fontWeightRegular,
		fontWeightMedium,
		fontWeightBold,
		h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
		h2: buildVariant(fontWeightLight, 60, 1.2, -.5),
		h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
		h4: buildVariant(fontWeightRegular, 34, 1.235, .25),
		h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
		h6: buildVariant(fontWeightMedium, 20, 1.6, .15),
		subtitle1: buildVariant(fontWeightRegular, 16, 1.75, .15),
		subtitle2: buildVariant(fontWeightMedium, 14, 1.57, .1),
		body1: buildVariant(fontWeightRegular, 16, 1.5, .15),
		body2: buildVariant(fontWeightRegular, 14, 1.43, .15),
		button: buildVariant(fontWeightMedium, 14, 1.75, .4, caseAllCaps),
		caption: buildVariant(fontWeightRegular, 12, 1.66, .4),
		overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
		inherit: {
			fontFamily: "inherit",
			fontWeight: "inherit",
			fontSize: "inherit",
			lineHeight: "inherit",
			letterSpacing: "inherit"
		}
	}, other, { clone: false });
}

//#endregion
//#region node_modules/@mui/material/esm/styles/shadows.js
var shadowKeyUmbraOpacity = .2;
var shadowKeyPenumbraOpacity = .14;
var shadowAmbientShadowOpacity = .12;
function createShadow(...px) {
	return [
		`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`,
		`${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`,
		`${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`
	].join(",");
}
var shadows = [
	"none",
	createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
	createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
	createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
	createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
	createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
	createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
	createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
	createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
	createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
	createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
	createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
	createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
	createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
	createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
	createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
	createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
	createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
	createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
	createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
	createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
	createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
	createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
	createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
	createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)
];
var shadows_default = shadows;

//#endregion
//#region node_modules/@mui/material/esm/styles/createTransitions.js
const easing = {
	easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
	easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
	easeIn: "cubic-bezier(0.4, 0, 1, 1)",
	sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
	shortest: 150,
	shorter: 200,
	short: 250,
	standard: 300,
	complex: 375,
	enteringScreen: 225,
	leavingScreen: 195
};
function formatMs(milliseconds) {
	return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height$1) {
	if (!height$1) return 0;
	const constant = height$1 / 36;
	return Math.min(Math.round((4 + 15 * constant ** .25 + constant / 5) * 10), 3e3);
}
function createTransitions(inputTransitions) {
	const mergedEasing = {
		...easing,
		...inputTransitions.easing
	};
	const mergedDuration = {
		...duration,
		...inputTransitions.duration
	};
	const create = (props = ["all"], options = {}) => {
		const { duration: durationOption = mergedDuration.standard, easing: easingOption = mergedEasing.easeInOut, delay = 0,...other } = options;
		{
			const isString = (value) => typeof value === "string";
			const isNumber = (value) => !Number.isNaN(parseFloat(value));
			if (!isString(props) && !Array.isArray(props)) console.error("MUI: Argument \"props\" must be a string or Array.");
			if (!isNumber(durationOption) && !isString(durationOption)) console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
			if (!isString(easingOption)) console.error("MUI: Argument \"easing\" must be a string.");
			if (!isNumber(delay) && !isString(delay)) console.error("MUI: Argument \"delay\" must be a number or a string.");
			if (typeof options !== "object") console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join("\n"));
			if (Object.keys(other).length !== 0) console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
		}
		return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
	};
	return {
		getAutoHeightDuration,
		create,
		...inputTransitions,
		easing: mergedEasing,
		duration: mergedDuration
	};
}

//#endregion
//#region node_modules/@mui/material/esm/styles/zIndex.js
var zIndex = {
	mobileStepper: 1e3,
	fab: 1050,
	speedDial: 1050,
	appBar: 1100,
	drawer: 1200,
	modal: 1300,
	snackbar: 1400,
	tooltip: 1500
};
var zIndex_default = zIndex;

//#endregion
//#region node_modules/@mui/material/esm/styles/stringifyTheme.js
function isSerializable(val) {
	return isPlainObject(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
}
/**
* `baseTheme` usually comes from `createTheme()` or `extendTheme()`.
*
* This function is intended to be used with zero-runtime CSS-in-JS like Pigment CSS
* For example, in a Next.js project:
*
* ```js
* // next.config.js
* const { extendTheme } = require('@mui/material/styles');
*
* const theme = extendTheme();
* // `.toRuntimeSource` is Pigment CSS specific to create a theme that is available at runtime.
* theme.toRuntimeSource = stringifyTheme;
*
* module.exports = withPigment({
*  theme,
* });
* ```
*/
function stringifyTheme(baseTheme = {}) {
	const serializableTheme = { ...baseTheme };
	function serializeTheme(object) {
		const array = Object.entries(object);
		for (let index = 0; index < array.length; index++) {
			const [key, value] = array[index];
			if (!isSerializable(value) || key.startsWith("unstable_")) delete object[key];
			else if (isPlainObject(value)) {
				object[key] = { ...value };
				serializeTheme(object[key]);
			}
		}
	}
	serializeTheme(serializableTheme);
	return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createThemeNoVars.js
function coefficientToPercentage(coefficient) {
	if (typeof coefficient === "number") return `${(coefficient * 100).toFixed(0)}%`;
	return `calc((${coefficient}) * 100%)`;
}
var parseAddition = (str) => {
	if (!Number.isNaN(+str)) return +str;
	const numbers = str.match(/\d*\.?\d+/g);
	if (!numbers) return 0;
	let sum = 0;
	for (let i = 0; i < numbers.length; i += 1) sum += +numbers[i];
	return sum;
};
function attachColorManipulators(theme) {
	Object.assign(theme, {
		alpha(color$1, coefficient) {
			const obj = this || theme;
			if (obj.colorSpace) return `oklch(from ${color$1} l c h / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
			if (obj.vars) return `rgba(${color$1.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof coefficient === "string" ? `calc(${coefficient})` : coefficient})`;
			return alpha(color$1, parseAddition(coefficient));
		},
		lighten(color$1, coefficient) {
			const obj = this || theme;
			if (obj.colorSpace) return `color-mix(in ${obj.colorSpace}, ${color$1}, #fff ${coefficientToPercentage(coefficient)})`;
			return lighten(color$1, coefficient);
		},
		darken(color$1, coefficient) {
			const obj = this || theme;
			if (obj.colorSpace) return `color-mix(in ${obj.colorSpace}, ${color$1}, #000 ${coefficientToPercentage(coefficient)})`;
			return darken(color$1, coefficient);
		}
	});
}
function createThemeNoVars(options = {}, ...args) {
	const { breakpoints: breakpointsInput, mixins: mixinsInput = {}, spacing: spacingInput, palette: paletteInput = {}, transitions: transitionsInput = {}, typography: typographyInput = {}, shape: shapeInput, colorSpace,...other } = options;
	if (options.vars && options.generateThemeVars === void 0) throw new Error("MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature.");
	const palette$1 = createPalette({
		...paletteInput,
		colorSpace
	});
	const systemTheme = createTheme_default(options);
	let muiTheme = deepmerge(systemTheme, {
		mixins: createMixins(systemTheme.breakpoints, mixinsInput),
		palette: palette$1,
		shadows: shadows_default.slice(),
		typography: createTypography(palette$1, typographyInput),
		transitions: createTransitions(transitionsInput),
		zIndex: { ...zIndex_default }
	});
	muiTheme = deepmerge(muiTheme, other);
	muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
	{
		const stateClasses = [
			"active",
			"checked",
			"completed",
			"disabled",
			"error",
			"expanded",
			"focused",
			"focusVisible",
			"required",
			"selected"
		];
		const traverse = (node, component) => {
			let key;
			for (key in node) {
				const child = node[key];
				if (stateClasses.includes(key) && Object.keys(child).length > 0) {
					{
						const stateClass = generateUtilityClass("", key);
						console.error([
							`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`,
							"You can not override it like this: ",
							JSON.stringify(node, null, 2),
							"",
							`Instead, you need to use the '&.${stateClass}' syntax:`,
							JSON.stringify({ root: { [`&.${stateClass}`]: child } }, null, 2),
							"",
							"https://mui.com/r/state-classes-guide"
						].join("\n"));
					}
					node[key] = {};
				}
			}
		};
		Object.keys(muiTheme.components).forEach((component) => {
			const styleOverrides = muiTheme.components[component].styleOverrides;
			if (styleOverrides && component.startsWith("Mui")) traverse(styleOverrides, component);
		});
	}
	muiTheme.unstable_sxConfig = {
		...defaultSxConfig_default,
		...other?.unstable_sxConfig
	};
	muiTheme.unstable_sx = function sx(props) {
		return styleFunctionSx_default({
			sx: props,
			theme: this
		});
	};
	muiTheme.toRuntimeSource = stringifyTheme;
	attachColorManipulators(muiTheme);
	return muiTheme;
}
var createThemeNoVars_default = createThemeNoVars;

//#endregion
//#region node_modules/@mui/material/esm/styles/getOverlayAlpha.js
function getOverlayAlpha(elevation) {
	let alphaValue;
	if (elevation < 1) alphaValue = 5.11916 * elevation ** 2;
	else alphaValue = 4.5 * Math.log(elevation + 1) + 2;
	return Math.round(alphaValue * 10) / 1e3;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createColorScheme.js
var defaultDarkOverlays = [...Array(25)].map((_, index) => {
	if (index === 0) return "none";
	const overlay = getOverlayAlpha(index);
	return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function getOpacity(mode) {
	return {
		inputPlaceholder: mode === "dark" ? .5 : .42,
		inputUnderline: mode === "dark" ? .7 : .42,
		switchTrackDisabled: mode === "dark" ? .2 : .12,
		switchTrack: mode === "dark" ? .3 : .38
	};
}
function getOverlays(mode) {
	return mode === "dark" ? defaultDarkOverlays : [];
}
function createColorScheme(options) {
	const { palette: paletteInput = { mode: "light" }, opacity, overlays, colorSpace,...other } = options;
	const palette$1 = createPalette({
		...paletteInput,
		colorSpace
	});
	return {
		palette: palette$1,
		opacity: {
			...getOpacity(palette$1.mode),
			...opacity
		},
		overlays: overlays || getOverlays(palette$1.mode),
		...other
	};
}

//#endregion
//#region node_modules/@mui/material/esm/styles/shouldSkipGeneratingVar.js
function shouldSkipGeneratingVar(keys) {
	return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || keys[0] === "palette" && !!keys[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}

//#endregion
//#region node_modules/@mui/material/esm/styles/excludeVariablesFromRoot.js
/**
* @internal These variables should not appear in the :root stylesheet when the `defaultColorScheme="dark"`
*/
var excludeVariablesFromRoot = (cssVarPrefix) => [
	...[...Array(25)].map((_, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index}`),
	`--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`,
	`--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`
];
var excludeVariablesFromRoot_default = excludeVariablesFromRoot;

//#endregion
//#region node_modules/@mui/material/esm/styles/createGetSelector.js
var createGetSelector_default = (theme) => (colorScheme, css$1) => {
	const root = theme.rootSelector || ":root";
	const selector = theme.colorSchemeSelector;
	let rule = selector;
	if (selector === "class") rule = ".%s";
	if (selector === "data") rule = "[data-%s]";
	if (selector?.startsWith("data-") && !selector.includes("%s")) rule = `[${selector}="%s"]`;
	if (theme.defaultColorScheme === colorScheme) {
		if (colorScheme === "dark") {
			const excludedVariables = {};
			excludeVariablesFromRoot_default(theme.cssVarPrefix).forEach((cssVar) => {
				excludedVariables[cssVar] = css$1[cssVar];
				delete css$1[cssVar];
			});
			if (rule === "media") return {
				[root]: css$1,
				[`@media (prefers-color-scheme: dark)`]: { [root]: excludedVariables }
			};
			if (rule) return {
				[rule.replace("%s", colorScheme)]: excludedVariables,
				[`${root}, ${rule.replace("%s", colorScheme)}`]: css$1
			};
			return { [root]: {
				...css$1,
				...excludedVariables
			} };
		}
		if (rule && rule !== "media") return `${root}, ${rule.replace("%s", String(colorScheme))}`;
	} else if (colorScheme) {
		if (rule === "media") return { [`@media (prefers-color-scheme: ${String(colorScheme)})`]: { [root]: css$1 } };
		if (rule) return rule.replace("%s", String(colorScheme));
	}
	return root;
};

//#endregion
//#region node_modules/@mui/material/esm/styles/createThemeWithVars.js
function assignNode(obj, keys) {
	keys.forEach((k) => {
		if (!obj[k]) obj[k] = {};
	});
}
function setColor(obj, key, defaultValue) {
	if (!obj[key] && defaultValue) obj[key] = defaultValue;
}
function toRgb(color$1) {
	if (typeof color$1 !== "string" || !color$1.startsWith("hsl")) return color$1;
	return hslToRgb(color$1);
}
function setColorChannel(obj, key) {
	if (!(`${key}Channel` in obj)) obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]), `MUI: Can't create \`palette.${key}Channel\` because \`palette.${key}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
}
function getSpacingVal(spacingInput) {
	if (typeof spacingInput === "number") return `${spacingInput}px`;
	if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) return spacingInput;
	return "8px";
}
var silent = (fn) => {
	try {
		return fn();
	} catch (error) {}
};
const createGetCssVar$1 = (cssVarPrefix = "mui") => createGetCssVar(cssVarPrefix);
function attachColorScheme$1(colorSpace, colorSchemes, scheme, restTheme, colorScheme) {
	if (!scheme) return;
	scheme = scheme === true ? {} : scheme;
	const mode = colorScheme === "dark" ? "dark" : "light";
	if (!restTheme) {
		colorSchemes[colorScheme] = createColorScheme({
			...scheme,
			palette: {
				mode,
				...scheme?.palette
			},
			colorSpace
		});
		return;
	}
	const { palette: palette$1,...muiTheme } = createThemeNoVars_default({
		...restTheme,
		palette: {
			mode,
			...scheme?.palette
		},
		colorSpace
	});
	colorSchemes[colorScheme] = {
		...scheme,
		palette: palette$1,
		opacity: {
			...getOpacity(mode),
			...scheme?.opacity
		},
		overlays: scheme?.overlays || getOverlays(mode)
	};
	return muiTheme;
}
/**
* A default `createThemeWithVars` comes with a single color scheme, either `light` or `dark` based on the `defaultColorScheme`.
* This is better suited for apps that only need a single color scheme.
*
* To enable built-in `light` and `dark` color schemes, either:
* 1. provide a `colorSchemeSelector` to define how the color schemes will change.
* 2. provide `colorSchemes.dark` will set `colorSchemeSelector: 'media'` by default.
*/
function createThemeWithVars(options = {}, ...args) {
	const { colorSchemes: colorSchemesInput = { light: true }, defaultColorScheme: defaultColorSchemeInput, disableCssColorScheme = false, cssVarPrefix = "mui", nativeColor = false, shouldSkipGeneratingVar: shouldSkipGeneratingVar$1 = shouldSkipGeneratingVar, colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0, rootSelector = ":root",...input } = options;
	const firstColorScheme = Object.keys(colorSchemesInput)[0];
	const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
	const getCssVar = createGetCssVar$1(cssVarPrefix);
	const { [defaultColorScheme]: defaultSchemeInput, light: builtInLight, dark: builtInDark,...customColorSchemes } = colorSchemesInput;
	const colorSchemes = { ...customColorSchemes };
	let defaultScheme = defaultSchemeInput;
	if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) defaultScheme = true;
	if (!defaultScheme) throw new Error(`MUI: The \`colorSchemes.${defaultColorScheme}\` option is either missing or invalid.`);
	let colorSpace;
	if (nativeColor) colorSpace = "oklch";
	const muiTheme = attachColorScheme$1(colorSpace, colorSchemes, defaultScheme, input, defaultColorScheme);
	if (builtInLight && !colorSchemes.light) attachColorScheme$1(colorSpace, colorSchemes, builtInLight, void 0, "light");
	if (builtInDark && !colorSchemes.dark) attachColorScheme$1(colorSpace, colorSchemes, builtInDark, void 0, "dark");
	let theme = {
		defaultColorScheme,
		...muiTheme,
		cssVarPrefix,
		colorSchemeSelector: selector,
		rootSelector,
		getCssVar,
		colorSchemes,
		font: {
			...prepareTypographyVars(muiTheme.typography),
			...muiTheme.font
		},
		spacing: getSpacingVal(input.spacing)
	};
	Object.keys(theme.colorSchemes).forEach((key) => {
		const palette$1 = theme.colorSchemes[key].palette;
		const setCssVarColor = (cssVar) => {
			const tokens = cssVar.split("-");
			const color$1 = tokens[1];
			const colorToken = tokens[2];
			return getCssVar(cssVar, palette$1[color$1][colorToken]);
		};
		if (palette$1.mode === "light") {
			setColor(palette$1.common, "background", "#fff");
			setColor(palette$1.common, "onBackground", "#000");
		}
		if (palette$1.mode === "dark") {
			setColor(palette$1.common, "background", "#000");
			setColor(palette$1.common, "onBackground", "#fff");
		}
		function colorMix(method, color$1, coefficient) {
			if (colorSpace) {
				let mixer;
				if (method === private_safeAlpha) mixer = `transparent ${((1 - coefficient) * 100).toFixed(0)}%`;
				if (method === private_safeDarken) mixer = `#000 ${(coefficient * 100).toFixed(0)}%`;
				if (method === private_safeLighten) mixer = `#fff ${(coefficient * 100).toFixed(0)}%`;
				return `color-mix(in ${colorSpace}, ${color$1}, ${mixer})`;
			}
			return method(color$1, coefficient);
		}
		assignNode(palette$1, [
			"Alert",
			"AppBar",
			"Avatar",
			"Button",
			"Chip",
			"FilledInput",
			"LinearProgress",
			"Skeleton",
			"Slider",
			"SnackbarContent",
			"SpeedDialAction",
			"StepConnector",
			"StepContent",
			"Switch",
			"TableCell",
			"Tooltip"
		]);
		if (palette$1.mode === "light") {
			setColor(palette$1.Alert, "errorColor", colorMix(private_safeDarken, palette$1.error.light, .6));
			setColor(palette$1.Alert, "infoColor", colorMix(private_safeDarken, palette$1.info.light, .6));
			setColor(palette$1.Alert, "successColor", colorMix(private_safeDarken, palette$1.success.light, .6));
			setColor(palette$1.Alert, "warningColor", colorMix(private_safeDarken, palette$1.warning.light, .6));
			setColor(palette$1.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
			setColor(palette$1.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
			setColor(palette$1.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
			setColor(palette$1.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
			setColor(palette$1.Alert, "errorFilledColor", silent(() => palette$1.getContrastText(palette$1.error.main)));
			setColor(palette$1.Alert, "infoFilledColor", silent(() => palette$1.getContrastText(palette$1.info.main)));
			setColor(palette$1.Alert, "successFilledColor", silent(() => palette$1.getContrastText(palette$1.success.main)));
			setColor(palette$1.Alert, "warningFilledColor", silent(() => palette$1.getContrastText(palette$1.warning.main)));
			setColor(palette$1.Alert, "errorStandardBg", colorMix(private_safeLighten, palette$1.error.light, .9));
			setColor(palette$1.Alert, "infoStandardBg", colorMix(private_safeLighten, palette$1.info.light, .9));
			setColor(palette$1.Alert, "successStandardBg", colorMix(private_safeLighten, palette$1.success.light, .9));
			setColor(palette$1.Alert, "warningStandardBg", colorMix(private_safeLighten, palette$1.warning.light, .9));
			setColor(palette$1.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
			setColor(palette$1.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
			setColor(palette$1.Alert, "successIconColor", setCssVarColor("palette-success-main"));
			setColor(palette$1.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
			setColor(palette$1.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
			setColor(palette$1.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
			setColor(palette$1.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
			setColor(palette$1.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
			setColor(palette$1.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
			setColor(palette$1.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
			setColor(palette$1.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
			setColor(palette$1.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
			setColor(palette$1.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
			setColor(palette$1.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
			setColor(palette$1.LinearProgress, "primaryBg", colorMix(private_safeLighten, palette$1.primary.main, .62));
			setColor(palette$1.LinearProgress, "secondaryBg", colorMix(private_safeLighten, palette$1.secondary.main, .62));
			setColor(palette$1.LinearProgress, "errorBg", colorMix(private_safeLighten, palette$1.error.main, .62));
			setColor(palette$1.LinearProgress, "infoBg", colorMix(private_safeLighten, palette$1.info.main, .62));
			setColor(palette$1.LinearProgress, "successBg", colorMix(private_safeLighten, palette$1.success.main, .62));
			setColor(palette$1.LinearProgress, "warningBg", colorMix(private_safeLighten, palette$1.warning.main, .62));
			setColor(palette$1.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette$1.text.primary, .11) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
			setColor(palette$1.Slider, "primaryTrack", colorMix(private_safeLighten, palette$1.primary.main, .62));
			setColor(palette$1.Slider, "secondaryTrack", colorMix(private_safeLighten, palette$1.secondary.main, .62));
			setColor(palette$1.Slider, "errorTrack", colorMix(private_safeLighten, palette$1.error.main, .62));
			setColor(palette$1.Slider, "infoTrack", colorMix(private_safeLighten, palette$1.info.main, .62));
			setColor(palette$1.Slider, "successTrack", colorMix(private_safeLighten, palette$1.success.main, .62));
			setColor(palette$1.Slider, "warningTrack", colorMix(private_safeLighten, palette$1.warning.main, .62));
			const snackbarContentBackground = colorSpace ? colorMix(private_safeDarken, palette$1.background.default, .6825) : private_safeEmphasize(palette$1.background.default, .8);
			setColor(palette$1.SnackbarContent, "bg", snackbarContentBackground);
			setColor(palette$1.SnackbarContent, "color", silent(() => colorSpace ? dark.text.primary : palette$1.getContrastText(snackbarContentBackground)));
			setColor(palette$1.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette$1.background.paper, .15));
			setColor(palette$1.StepConnector, "border", setCssVarColor("palette-grey-400"));
			setColor(palette$1.StepContent, "border", setCssVarColor("palette-grey-400"));
			setColor(palette$1.Switch, "defaultColor", setCssVarColor("palette-common-white"));
			setColor(palette$1.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
			setColor(palette$1.Switch, "primaryDisabledColor", colorMix(private_safeLighten, palette$1.primary.main, .62));
			setColor(palette$1.Switch, "secondaryDisabledColor", colorMix(private_safeLighten, palette$1.secondary.main, .62));
			setColor(palette$1.Switch, "errorDisabledColor", colorMix(private_safeLighten, palette$1.error.main, .62));
			setColor(palette$1.Switch, "infoDisabledColor", colorMix(private_safeLighten, palette$1.info.main, .62));
			setColor(palette$1.Switch, "successDisabledColor", colorMix(private_safeLighten, palette$1.success.main, .62));
			setColor(palette$1.Switch, "warningDisabledColor", colorMix(private_safeLighten, palette$1.warning.main, .62));
			setColor(palette$1.TableCell, "border", colorMix(private_safeLighten, colorMix(private_safeAlpha, palette$1.divider, 1), .88));
			setColor(palette$1.Tooltip, "bg", colorMix(private_safeAlpha, palette$1.grey[700], .92));
		}
		if (palette$1.mode === "dark") {
			setColor(palette$1.Alert, "errorColor", colorMix(private_safeLighten, palette$1.error.light, .6));
			setColor(palette$1.Alert, "infoColor", colorMix(private_safeLighten, palette$1.info.light, .6));
			setColor(palette$1.Alert, "successColor", colorMix(private_safeLighten, palette$1.success.light, .6));
			setColor(palette$1.Alert, "warningColor", colorMix(private_safeLighten, palette$1.warning.light, .6));
			setColor(palette$1.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
			setColor(palette$1.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
			setColor(palette$1.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
			setColor(palette$1.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
			setColor(palette$1.Alert, "errorFilledColor", silent(() => palette$1.getContrastText(palette$1.error.dark)));
			setColor(palette$1.Alert, "infoFilledColor", silent(() => palette$1.getContrastText(palette$1.info.dark)));
			setColor(palette$1.Alert, "successFilledColor", silent(() => palette$1.getContrastText(palette$1.success.dark)));
			setColor(palette$1.Alert, "warningFilledColor", silent(() => palette$1.getContrastText(palette$1.warning.dark)));
			setColor(palette$1.Alert, "errorStandardBg", colorMix(private_safeDarken, palette$1.error.light, .9));
			setColor(palette$1.Alert, "infoStandardBg", colorMix(private_safeDarken, palette$1.info.light, .9));
			setColor(palette$1.Alert, "successStandardBg", colorMix(private_safeDarken, palette$1.success.light, .9));
			setColor(palette$1.Alert, "warningStandardBg", colorMix(private_safeDarken, palette$1.warning.light, .9));
			setColor(palette$1.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
			setColor(palette$1.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
			setColor(palette$1.Alert, "successIconColor", setCssVarColor("palette-success-main"));
			setColor(palette$1.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
			setColor(palette$1.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
			setColor(palette$1.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
			setColor(palette$1.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
			setColor(palette$1.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
			setColor(palette$1.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
			setColor(palette$1.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
			setColor(palette$1.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
			setColor(palette$1.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
			setColor(palette$1.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
			setColor(palette$1.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
			setColor(palette$1.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
			setColor(palette$1.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
			setColor(palette$1.LinearProgress, "primaryBg", colorMix(private_safeDarken, palette$1.primary.main, .5));
			setColor(palette$1.LinearProgress, "secondaryBg", colorMix(private_safeDarken, palette$1.secondary.main, .5));
			setColor(palette$1.LinearProgress, "errorBg", colorMix(private_safeDarken, palette$1.error.main, .5));
			setColor(palette$1.LinearProgress, "infoBg", colorMix(private_safeDarken, palette$1.info.main, .5));
			setColor(palette$1.LinearProgress, "successBg", colorMix(private_safeDarken, palette$1.success.main, .5));
			setColor(palette$1.LinearProgress, "warningBg", colorMix(private_safeDarken, palette$1.warning.main, .5));
			setColor(palette$1.Skeleton, "bg", colorSpace ? colorMix(private_safeAlpha, palette$1.text.primary, .13) : `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
			setColor(palette$1.Slider, "primaryTrack", colorMix(private_safeDarken, palette$1.primary.main, .5));
			setColor(palette$1.Slider, "secondaryTrack", colorMix(private_safeDarken, palette$1.secondary.main, .5));
			setColor(palette$1.Slider, "errorTrack", colorMix(private_safeDarken, palette$1.error.main, .5));
			setColor(palette$1.Slider, "infoTrack", colorMix(private_safeDarken, palette$1.info.main, .5));
			setColor(palette$1.Slider, "successTrack", colorMix(private_safeDarken, palette$1.success.main, .5));
			setColor(palette$1.Slider, "warningTrack", colorMix(private_safeDarken, palette$1.warning.main, .5));
			const snackbarContentBackground = colorSpace ? colorMix(private_safeLighten, palette$1.background.default, .985) : private_safeEmphasize(palette$1.background.default, .98);
			setColor(palette$1.SnackbarContent, "bg", snackbarContentBackground);
			setColor(palette$1.SnackbarContent, "color", silent(() => colorSpace ? light.text.primary : palette$1.getContrastText(snackbarContentBackground)));
			setColor(palette$1.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette$1.background.paper, .15));
			setColor(palette$1.StepConnector, "border", setCssVarColor("palette-grey-600"));
			setColor(palette$1.StepContent, "border", setCssVarColor("palette-grey-600"));
			setColor(palette$1.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
			setColor(palette$1.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
			setColor(palette$1.Switch, "primaryDisabledColor", colorMix(private_safeDarken, palette$1.primary.main, .55));
			setColor(palette$1.Switch, "secondaryDisabledColor", colorMix(private_safeDarken, palette$1.secondary.main, .55));
			setColor(palette$1.Switch, "errorDisabledColor", colorMix(private_safeDarken, palette$1.error.main, .55));
			setColor(palette$1.Switch, "infoDisabledColor", colorMix(private_safeDarken, palette$1.info.main, .55));
			setColor(palette$1.Switch, "successDisabledColor", colorMix(private_safeDarken, palette$1.success.main, .55));
			setColor(palette$1.Switch, "warningDisabledColor", colorMix(private_safeDarken, palette$1.warning.main, .55));
			setColor(palette$1.TableCell, "border", colorMix(private_safeDarken, colorMix(private_safeAlpha, palette$1.divider, 1), .68));
			setColor(palette$1.Tooltip, "bg", colorMix(private_safeAlpha, palette$1.grey[700], .92));
		}
		setColorChannel(palette$1.background, "default");
		setColorChannel(palette$1.background, "paper");
		setColorChannel(palette$1.common, "background");
		setColorChannel(palette$1.common, "onBackground");
		setColorChannel(palette$1, "divider");
		Object.keys(palette$1).forEach((color$1) => {
			const colors = palette$1[color$1];
			if (color$1 !== "tonalOffset" && colors && typeof colors === "object") {
				if (colors.main) setColor(palette$1[color$1], "mainChannel", private_safeColorChannel(toRgb(colors.main)));
				if (colors.light) setColor(palette$1[color$1], "lightChannel", private_safeColorChannel(toRgb(colors.light)));
				if (colors.dark) setColor(palette$1[color$1], "darkChannel", private_safeColorChannel(toRgb(colors.dark)));
				if (colors.contrastText) setColor(palette$1[color$1], "contrastTextChannel", private_safeColorChannel(toRgb(colors.contrastText)));
				if (color$1 === "text") {
					setColorChannel(palette$1[color$1], "primary");
					setColorChannel(palette$1[color$1], "secondary");
				}
				if (color$1 === "action") {
					if (colors.active) setColorChannel(palette$1[color$1], "active");
					if (colors.selected) setColorChannel(palette$1[color$1], "selected");
				}
			}
		});
	});
	theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
	const parserConfig = {
		prefix: cssVarPrefix,
		disableCssColorScheme,
		shouldSkipGeneratingVar: shouldSkipGeneratingVar$1,
		getSelector: createGetSelector_default(theme),
		enableContrastVars: nativeColor
	};
	const { vars, generateThemeVars, generateStyleSheets } = prepareCssVars_default(theme, parserConfig);
	theme.vars = vars;
	Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
		theme[key] = value;
	});
	theme.generateThemeVars = generateThemeVars;
	theme.generateStyleSheets = generateStyleSheets;
	theme.generateSpacing = function generateSpacing() {
		return createSpacing(input.spacing, createUnarySpacing(this));
	};
	theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
	theme.spacing = theme.generateSpacing();
	theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar$1;
	theme.unstable_sxConfig = {
		...defaultSxConfig_default,
		...input?.unstable_sxConfig
	};
	theme.unstable_sx = function sx(props) {
		return styleFunctionSx_default({
			sx: props,
			theme: this
		});
	};
	theme.toRuntimeSource = stringifyTheme;
	return theme;
}

//#endregion
//#region node_modules/@mui/material/esm/styles/createTheme.js
function attachColorScheme(theme, scheme, colorScheme) {
	if (!theme.colorSchemes) return;
	if (colorScheme) theme.colorSchemes[scheme] = {
		...colorScheme !== true && colorScheme,
		palette: createPalette({
			...colorScheme === true ? {} : colorScheme.palette,
			mode: scheme
		})
	};
}
/**
* Generate a theme base on the options received.
* @param options Takes an incomplete theme object and adds the missing parts.
* @param args Deep merge the arguments with the about to be returned theme.
* @returns A complete, ready-to-use theme object.
*/
function createTheme(options = {}, ...args) {
	const { palette: palette$1, cssVariables = false, colorSchemes: initialColorSchemes = !palette$1 ? { light: true } : void 0, defaultColorScheme: initialDefaultColorScheme = palette$1?.mode,...other } = options;
	const defaultColorSchemeInput = initialDefaultColorScheme || "light";
	const defaultScheme = initialColorSchemes?.[defaultColorSchemeInput];
	const colorSchemesInput = {
		...initialColorSchemes,
		...palette$1 ? { [defaultColorSchemeInput]: {
			...typeof defaultScheme !== "boolean" && defaultScheme,
			palette: palette$1
		} } : void 0
	};
	if (cssVariables === false) {
		if (!("colorSchemes" in options)) return createThemeNoVars_default(options, ...args);
		let paletteOptions = palette$1;
		if (!("palette" in options)) {
			if (colorSchemesInput[defaultColorSchemeInput]) {
				if (colorSchemesInput[defaultColorSchemeInput] !== true) paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
				else if (defaultColorSchemeInput === "dark") paletteOptions = { mode: "dark" };
			}
		}
		const theme = createThemeNoVars_default({
			...options,
			palette: paletteOptions
		}, ...args);
		theme.defaultColorScheme = defaultColorSchemeInput;
		theme.colorSchemes = colorSchemesInput;
		if (theme.palette.mode === "light") {
			theme.colorSchemes.light = {
				...colorSchemesInput.light !== true && colorSchemesInput.light,
				palette: theme.palette
			};
			attachColorScheme(theme, "dark", colorSchemesInput.dark);
		}
		if (theme.palette.mode === "dark") {
			theme.colorSchemes.dark = {
				...colorSchemesInput.dark !== true && colorSchemesInput.dark,
				palette: theme.palette
			};
			attachColorScheme(theme, "light", colorSchemesInput.light);
		}
		return theme;
	}
	if (!palette$1 && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") colorSchemesInput.light = true;
	return createThemeWithVars({
		...other,
		colorSchemes: colorSchemesInput,
		defaultColorScheme: defaultColorSchemeInput,
		...typeof cssVariables !== "boolean" && cssVariables
	}, ...args);
}

//#endregion
//#region node_modules/@mui/material/esm/styles/defaultTheme.js
var defaultTheme = createTheme();
var defaultTheme_default = defaultTheme;

//#endregion
//#region node_modules/@mui/material/esm/styles/slotShouldForwardProp.js
function slotShouldForwardProp(prop) {
	return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
var slotShouldForwardProp_default = slotShouldForwardProp;

//#endregion
//#region node_modules/@mui/material/esm/styles/rootShouldForwardProp.js
var rootShouldForwardProp = (prop) => slotShouldForwardProp_default(prop) && prop !== "classes";
var rootShouldForwardProp_default = rootShouldForwardProp;

//#endregion
//#region node_modules/@mui/material/esm/styles/styled.js
var styled = createStyled({
	themeId: identifier_default,
	defaultTheme: defaultTheme_default,
	rootShouldForwardProp: rootShouldForwardProp_default
});
var styled_default = styled;

//#endregion
export { createSpacing as $, DefaultPropsProvider_default as A, hexToRgb as B, common_default as C, unstable_memoTheme as D, InitColorSchemeScript as E, darken as F, clamp_default as G, lighten as H, decomposeColor as I, generateUtilityClass as J, useThemeProps as K, emphasize as L, useRtl as M, exactProp as N, ThemeProvider_default as O, alpha as P, createTheme_default as Q, getContrastRatio as R, grey_default as S, createCssVarsProvider as T, recomposeColor as U, hslToRgb as V, rgbToHex as W, GlobalStyles_default as X, ClassNameGenerator_default as Y, useTheme_default as Z, lightBlue_default as _, createTheme as a, getPath as at, red_default as b, shouldSkipGeneratingVar as c, resolveBreakpointValues as ct, createTransitions as d, require_react_is as dt, createBreakpoints as et, duration as f, capitalize as ft, green_default as g, createMixins as h, defaultTheme_default as i, getValue as it, useDefaultProps as j, useId as k, createColorScheme as l, deepmerge as lt, createTypography as m, rootShouldForwardProp_default as n, defaultSxConfig_default as nt, createThemeWithVars as o, handleBreakpoints as ot, easing as p, composeClasses as pt, styled_default$1 as q, slotShouldForwardProp_default as r, createUnarySpacing as rt, excludeVariablesFromRoot_default as s, mergeBreakpointsInOrder as st, styled_default as t, styleFunctionSx_default as tt, getOverlayAlpha as u, isPlainObject as ut, blue_default as v, createContainer as w, purple_default as x, orange_default as y, getLuminance as z };
//# sourceMappingURL=styled-DfHdmIiH.js.map