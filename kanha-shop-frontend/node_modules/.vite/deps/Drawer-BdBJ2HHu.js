import { r as __toESM } from "./chunk-DUEDWNxO.js";
import { t as require_prop_types } from "./prop-types-1UMy44yP.js";
import { t as require_react } from "./react-Cp03pb_8.js";
import { _ as clsx_default } from "./identifier-B78u7x71.js";
import { J as generateUtilityClass, M as useRtl, n as rootShouldForwardProp_default, pt as composeClasses, t as styled_default } from "./styled-DfHdmIiH.js";
import { t as require_jsx_runtime } from "./jsx-runtime-2dA6yi1W.js";
import { t as generateUtilityClasses } from "./generateUtilityClasses-Ch_vthMU.js";
import { t as useTheme } from "./useTheme-BBm7PRLi.js";
import { t as useDefaultProps } from "./DefaultPropsProvider-HgBh68uR.js";
import { t as capitalize_default } from "./capitalize-m7U6UdsQ.js";
import { i as ownerWindow_default, n as mergeSlotProps, s as debounce_default } from "./utils-B3AJVED3.js";
import { t as memoTheme_default } from "./memoTheme-BXp7hqOr.js";
import { t as useForkRef_default } from "./useForkRef-C-ufhScl.js";
import { t as chainPropTypes } from "./chainPropTypes-sulWJOPN.js";
import { a as Transition_default, i as reflow, n as getReactElementRef, r as getTransitionProps, t as elementAcceptingRef_default } from "./elementAcceptingRef-uRwn7k-h.js";
import { t as useSlot } from "./useSlot-BusZDecY.js";
import { t as integerPropType_default } from "./integerPropType-DOHtaYEZ.js";
import { t as Paper_default } from "./Paper-DZ8-QDVF.js";
import { n as HTMLElementType } from "./Portal-BrxXB9_Z.js";
import { t as Modal_default } from "./Modal-Br7HcHjw.js";

//#region node_modules/@mui/material/esm/Slide/Slide.js
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
var import_prop_types$1 = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
function getTranslateValue(direction, node, resolvedContainer) {
	const rect = node.getBoundingClientRect();
	const containerRect = resolvedContainer && resolvedContainer.getBoundingClientRect();
	const containerWindow = ownerWindow_default(node);
	let transform;
	if (node.fakeTransform) transform = node.fakeTransform;
	else {
		const computedStyle = containerWindow.getComputedStyle(node);
		transform = computedStyle.getPropertyValue("-webkit-transform") || computedStyle.getPropertyValue("transform");
	}
	let offsetX = 0;
	let offsetY = 0;
	if (transform && transform !== "none" && typeof transform === "string") {
		const transformValues = transform.split("(")[1].split(")")[0].split(",");
		offsetX = parseInt(transformValues[4], 10);
		offsetY = parseInt(transformValues[5], 10);
	}
	if (direction === "left") {
		if (containerRect) return `translateX(${containerRect.right + offsetX - rect.left}px)`;
		return `translateX(${containerWindow.innerWidth + offsetX - rect.left}px)`;
	}
	if (direction === "right") {
		if (containerRect) return `translateX(-${rect.right - containerRect.left - offsetX}px)`;
		return `translateX(-${rect.left + rect.width - offsetX}px)`;
	}
	if (direction === "up") {
		if (containerRect) return `translateY(${containerRect.bottom + offsetY - rect.top}px)`;
		return `translateY(${containerWindow.innerHeight + offsetY - rect.top}px)`;
	}
	if (containerRect) return `translateY(-${rect.top - containerRect.top + rect.height - offsetY}px)`;
	return `translateY(-${rect.top + rect.height - offsetY}px)`;
}
function resolveContainer(containerPropProp) {
	return typeof containerPropProp === "function" ? containerPropProp() : containerPropProp;
}
function setTranslateValue(direction, node, containerProp) {
	const transform = getTranslateValue(direction, node, resolveContainer(containerProp));
	if (transform) {
		node.style.webkitTransform = transform;
		node.style.transform = transform;
	}
}
/**
* The Slide transition is used by the [Drawer](/material-ui/react-drawer/) component.
* It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
*/
var Slide = /* @__PURE__ */ import_react.forwardRef(function Slide$1(props, ref) {
	const theme = useTheme();
	const defaultEasing = {
		enter: theme.transitions.easing.easeOut,
		exit: theme.transitions.easing.sharp
	};
	const defaultTimeout = {
		enter: theme.transitions.duration.enteringScreen,
		exit: theme.transitions.duration.leavingScreen
	};
	const { addEndListener, appear = true, children, container: containerProp, direction = "down", easing: easingProp = defaultEasing, in: inProp, onEnter, onEntered, onEntering, onExit, onExited, onExiting, style, timeout = defaultTimeout, TransitionComponent = Transition_default,...other } = props;
	const childrenRef = import_react.useRef(null);
	const handleRef = useForkRef_default(getReactElementRef(children), childrenRef, ref);
	const normalizedTransitionCallback = (callback) => (isAppearing) => {
		if (callback) if (isAppearing === void 0) callback(childrenRef.current);
		else callback(childrenRef.current, isAppearing);
	};
	const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
		setTranslateValue(direction, node, containerProp);
		reflow(node);
		if (onEnter) onEnter(node, isAppearing);
	});
	const handleEntering = normalizedTransitionCallback((node, isAppearing) => {
		const transitionProps = getTransitionProps({
			timeout,
			style,
			easing: easingProp
		}, { mode: "enter" });
		node.style.webkitTransition = theme.transitions.create("-webkit-transform", { ...transitionProps });
		node.style.transition = theme.transitions.create("transform", { ...transitionProps });
		node.style.webkitTransform = "none";
		node.style.transform = "none";
		if (onEntering) onEntering(node, isAppearing);
	});
	const handleEntered = normalizedTransitionCallback(onEntered);
	const handleExiting = normalizedTransitionCallback(onExiting);
	const handleExit = normalizedTransitionCallback((node) => {
		const transitionProps = getTransitionProps({
			timeout,
			style,
			easing: easingProp
		}, { mode: "exit" });
		node.style.webkitTransition = theme.transitions.create("-webkit-transform", transitionProps);
		node.style.transition = theme.transitions.create("transform", transitionProps);
		setTranslateValue(direction, node, containerProp);
		if (onExit) onExit(node);
	});
	const handleExited = normalizedTransitionCallback((node) => {
		node.style.webkitTransition = "";
		node.style.transition = "";
		if (onExited) onExited(node);
	});
	const handleAddEndListener = (next) => {
		if (addEndListener) addEndListener(childrenRef.current, next);
	};
	const updatePosition = import_react.useCallback(() => {
		if (childrenRef.current) setTranslateValue(direction, childrenRef.current, containerProp);
	}, [direction, containerProp]);
	import_react.useEffect(() => {
		if (inProp || direction === "down" || direction === "right") return;
		const handleResize = debounce_default(() => {
			if (childrenRef.current) setTranslateValue(direction, childrenRef.current, containerProp);
		});
		const containerWindow = ownerWindow_default(childrenRef.current);
		containerWindow.addEventListener("resize", handleResize);
		return () => {
			handleResize.clear();
			containerWindow.removeEventListener("resize", handleResize);
		};
	}, [
		direction,
		inProp,
		containerProp
	]);
	import_react.useEffect(() => {
		if (!inProp) updatePosition();
	}, [inProp, updatePosition]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TransitionComponent, {
		nodeRef: childrenRef,
		onEnter: handleEnter,
		onEntered: handleEntered,
		onEntering: handleEntering,
		onExit: handleExit,
		onExited: handleExited,
		onExiting: handleExiting,
		addEndListener: handleAddEndListener,
		appear,
		in: inProp,
		timeout,
		...other,
		children: (state, { ownerState,...restChildProps }) => {
			return /* @__PURE__ */ import_react.cloneElement(children, {
				ref: handleRef,
				style: {
					visibility: state === "exited" && !inProp ? "hidden" : void 0,
					...style,
					...children.props.style
				},
				...restChildProps
			});
		}
	});
});
Slide.propTypes = {
	addEndListener: import_prop_types$1.default.func,
	appear: import_prop_types$1.default.bool,
	children: elementAcceptingRef_default.isRequired,
	container: chainPropTypes(import_prop_types$1.default.oneOfType([HTMLElementType, import_prop_types$1.default.func]), (props) => {
		if (props.open) {
			const resolvedContainer = resolveContainer(props.container);
			if (resolvedContainer && resolvedContainer.nodeType === 1) {
				const box = resolvedContainer.getBoundingClientRect();
				if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) return new Error([
					"MUI: The `container` prop provided to the component is invalid.",
					"The anchor element should be part of the document layout.",
					"Make sure the element is present in the document or that it's not display none."
				].join("\n"));
			} else if (!resolvedContainer || typeof resolvedContainer.getBoundingClientRect !== "function" || resolvedContainer.contextElement != null && resolvedContainer.contextElement.nodeType !== 1) return new Error(["MUI: The `container` prop provided to the component is invalid.", "It should be an HTML element instance."].join("\n"));
		}
		return null;
	}),
	direction: import_prop_types$1.default.oneOf([
		"down",
		"left",
		"right",
		"up"
	]),
	easing: import_prop_types$1.default.oneOfType([import_prop_types$1.default.shape({
		enter: import_prop_types$1.default.string,
		exit: import_prop_types$1.default.string
	}), import_prop_types$1.default.string]),
	in: import_prop_types$1.default.bool,
	onEnter: import_prop_types$1.default.func,
	onEntered: import_prop_types$1.default.func,
	onEntering: import_prop_types$1.default.func,
	onExit: import_prop_types$1.default.func,
	onExited: import_prop_types$1.default.func,
	onExiting: import_prop_types$1.default.func,
	style: import_prop_types$1.default.object,
	timeout: import_prop_types$1.default.oneOfType([import_prop_types$1.default.number, import_prop_types$1.default.shape({
		appear: import_prop_types$1.default.number,
		enter: import_prop_types$1.default.number,
		exit: import_prop_types$1.default.number
	})])
};
var Slide_default = Slide;

//#endregion
//#region node_modules/@mui/material/esm/Drawer/drawerClasses.js
function getDrawerUtilityClass(slot) {
	return generateUtilityClass("MuiDrawer", slot);
}
var drawerClasses = generateUtilityClasses("MuiDrawer", [
	"root",
	"docked",
	"paper",
	"anchorLeft",
	"anchorRight",
	"anchorTop",
	"anchorBottom",
	"paperAnchorLeft",
	"paperAnchorRight",
	"paperAnchorTop",
	"paperAnchorBottom",
	"paperAnchorDockedLeft",
	"paperAnchorDockedRight",
	"paperAnchorDockedTop",
	"paperAnchorDockedBottom",
	"modal"
]);
var drawerClasses_default = drawerClasses;

//#endregion
//#region node_modules/@mui/material/esm/Drawer/Drawer.js
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var overridesResolver = (props, styles) => {
	const { ownerState } = props;
	return [
		styles.root,
		(ownerState.variant === "permanent" || ownerState.variant === "persistent") && styles.docked,
		styles.modal
	];
};
var useUtilityClasses = (ownerState) => {
	const { classes, anchor, variant } = ownerState;
	return composeClasses({
		root: ["root", `anchor${capitalize_default(anchor)}`],
		docked: [(variant === "permanent" || variant === "persistent") && "docked"],
		modal: ["modal"],
		paper: [
			"paper",
			`paperAnchor${capitalize_default(anchor)}`,
			variant !== "temporary" && `paperAnchorDocked${capitalize_default(anchor)}`
		]
	}, getDrawerUtilityClass, classes);
};
var DrawerRoot = styled_default(Modal_default, {
	name: "MuiDrawer",
	slot: "Root",
	overridesResolver
})(memoTheme_default(({ theme }) => ({ zIndex: (theme.vars || theme).zIndex.drawer })));
var DrawerDockedRoot = styled_default("div", {
	shouldForwardProp: rootShouldForwardProp_default,
	name: "MuiDrawer",
	slot: "Docked",
	skipVariantsResolver: false,
	overridesResolver
})({ flex: "0 0 auto" });
var DrawerPaper = styled_default(Paper_default, {
	name: "MuiDrawer",
	slot: "Paper",
	overridesResolver: (props, styles) => {
		const { ownerState } = props;
		return [
			styles.paper,
			styles[`paperAnchor${capitalize_default(ownerState.anchor)}`],
			ownerState.variant !== "temporary" && styles[`paperAnchorDocked${capitalize_default(ownerState.anchor)}`]
		];
	}
})(memoTheme_default(({ theme }) => ({
	overflowY: "auto",
	display: "flex",
	flexDirection: "column",
	height: "100%",
	flex: "1 0 auto",
	zIndex: (theme.vars || theme).zIndex.drawer,
	WebkitOverflowScrolling: "touch",
	position: "fixed",
	top: 0,
	outline: 0,
	variants: [
		{
			props: { anchor: "left" },
			style: { left: 0 }
		},
		{
			props: { anchor: "top" },
			style: {
				top: 0,
				left: 0,
				right: 0,
				height: "auto",
				maxHeight: "100%"
			}
		},
		{
			props: { anchor: "right" },
			style: { right: 0 }
		},
		{
			props: { anchor: "bottom" },
			style: {
				top: "auto",
				left: 0,
				bottom: 0,
				right: 0,
				height: "auto",
				maxHeight: "100%"
			}
		},
		{
			props: ({ ownerState }) => ownerState.anchor === "left" && ownerState.variant !== "temporary",
			style: { borderRight: `1px solid ${(theme.vars || theme).palette.divider}` }
		},
		{
			props: ({ ownerState }) => ownerState.anchor === "top" && ownerState.variant !== "temporary",
			style: { borderBottom: `1px solid ${(theme.vars || theme).palette.divider}` }
		},
		{
			props: ({ ownerState }) => ownerState.anchor === "right" && ownerState.variant !== "temporary",
			style: { borderLeft: `1px solid ${(theme.vars || theme).palette.divider}` }
		},
		{
			props: ({ ownerState }) => ownerState.anchor === "bottom" && ownerState.variant !== "temporary",
			style: { borderTop: `1px solid ${(theme.vars || theme).palette.divider}` }
		}
	]
})));
var oppositeDirection = {
	left: "right",
	right: "left",
	top: "down",
	bottom: "up"
};
function isHorizontal(anchor) {
	return ["left", "right"].includes(anchor);
}
function getAnchor({ direction }, anchor) {
	return direction === "rtl" && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;
}
/**
* The props of the [Modal](/material-ui/api/modal/) component are available
* when `variant="temporary"` is set.
*/
var Drawer = /* @__PURE__ */ import_react.forwardRef(function Drawer$1(inProps, ref) {
	const props = useDefaultProps({
		props: inProps,
		name: "MuiDrawer"
	});
	const theme = useTheme();
	const isRtl = useRtl();
	const defaultTransitionDuration = {
		enter: theme.transitions.duration.enteringScreen,
		exit: theme.transitions.duration.leavingScreen
	};
	const { anchor: anchorProp = "left", BackdropProps, children, className, elevation = 16, hideBackdrop = false, ModalProps: { BackdropProps: BackdropPropsProp,...ModalProps } = {}, onClose, open = false, PaperProps = {}, SlideProps, TransitionComponent, transitionDuration = defaultTransitionDuration, variant = "temporary", slots = {}, slotProps = {},...other } = props;
	const mounted = import_react.useRef(false);
	import_react.useEffect(() => {
		mounted.current = true;
	}, []);
	const anchorInvariant = getAnchor({ direction: isRtl ? "rtl" : "ltr" }, anchorProp);
	const anchor = anchorProp;
	const ownerState = {
		...props,
		anchor,
		elevation,
		open,
		variant,
		...other
	};
	const classes = useUtilityClasses(ownerState);
	const externalForwardedProps = {
		slots: {
			transition: TransitionComponent,
			...slots
		},
		slotProps: {
			paper: PaperProps,
			transition: SlideProps,
			...slotProps,
			backdrop: mergeSlotProps(slotProps.backdrop || {
				...BackdropProps,
				...BackdropPropsProp
			}, { transitionDuration })
		}
	};
	const [RootSlot, rootSlotProps] = useSlot("root", {
		ref,
		elementType: DrawerRoot,
		className: clsx_default(classes.root, classes.modal, className),
		shouldForwardComponentProp: true,
		ownerState,
		externalForwardedProps: {
			...externalForwardedProps,
			...other,
			...ModalProps
		},
		additionalProps: {
			open,
			onClose,
			hideBackdrop,
			slots: { backdrop: externalForwardedProps.slots.backdrop },
			slotProps: { backdrop: externalForwardedProps.slotProps.backdrop }
		}
	});
	const [PaperSlot, paperSlotProps] = useSlot("paper", {
		elementType: DrawerPaper,
		shouldForwardComponentProp: true,
		className: clsx_default(classes.paper, PaperProps.className),
		ownerState,
		externalForwardedProps,
		additionalProps: {
			elevation: variant === "temporary" ? elevation : 0,
			square: true,
			...variant === "temporary" && {
				role: "dialog",
				"aria-modal": "true"
			}
		}
	});
	const [DockedSlot, dockedSlotProps] = useSlot("docked", {
		elementType: DrawerDockedRoot,
		ref,
		className: clsx_default(classes.root, classes.docked, className),
		ownerState,
		externalForwardedProps,
		additionalProps: other
	});
	const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
		elementType: Slide_default,
		ownerState,
		externalForwardedProps,
		additionalProps: {
			in: open,
			direction: oppositeDirection[anchorInvariant],
			timeout: transitionDuration,
			appear: mounted.current
		}
	});
	const drawer = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PaperSlot, {
		...paperSlotProps,
		children
	});
	if (variant === "permanent") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DockedSlot, {
		...dockedSlotProps,
		children: drawer
	});
	const slidingDrawer = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TransitionSlot, {
		...transitionSlotProps,
		children: drawer
	});
	if (variant === "persistent") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DockedSlot, {
		...dockedSlotProps,
		children: slidingDrawer
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RootSlot, {
		...rootSlotProps,
		children: slidingDrawer
	});
});
Drawer.propTypes = {
	anchor: import_prop_types.default.oneOf([
		"bottom",
		"left",
		"right",
		"top"
	]),
	BackdropProps: import_prop_types.default.object,
	children: import_prop_types.default.node,
	classes: import_prop_types.default.object,
	className: import_prop_types.default.string,
	elevation: integerPropType_default,
	hideBackdrop: import_prop_types.default.bool,
	ModalProps: import_prop_types.default.object,
	onClose: import_prop_types.default.func,
	open: import_prop_types.default.bool,
	PaperProps: import_prop_types.default.object,
	SlideProps: import_prop_types.default.object,
	slotProps: import_prop_types.default.shape({
		backdrop: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
		docked: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
		paper: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
		root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
		transition: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
	}),
	slots: import_prop_types.default.shape({
		backdrop: import_prop_types.default.elementType,
		docked: import_prop_types.default.elementType,
		paper: import_prop_types.default.elementType,
		root: import_prop_types.default.elementType,
		transition: import_prop_types.default.elementType
	}),
	sx: import_prop_types.default.oneOfType([
		import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([
			import_prop_types.default.func,
			import_prop_types.default.object,
			import_prop_types.default.bool
		])),
		import_prop_types.default.func,
		import_prop_types.default.object
	]),
	transitionDuration: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
		appear: import_prop_types.default.number,
		enter: import_prop_types.default.number,
		exit: import_prop_types.default.number
	})]),
	variant: import_prop_types.default.oneOf([
		"permanent",
		"persistent",
		"temporary"
	])
};
var Drawer_default = Drawer;

//#endregion
export { getDrawerUtilityClass as a, drawerClasses_default as i, getAnchor as n, Slide_default as o, isHorizontal as r, Drawer_default as t };
//# sourceMappingURL=Drawer-BdBJ2HHu.js.map